# Generated by generate_sdk_wrappers.py. DO NOT EDIT

from abc import ABCMeta
from dataclasses import dataclass, field
from typing import Any, Optional
from uuid import uuid4

from luminarycloud.tables import RectilinearTable, _param_name_to_table_type
from google.protobuf.message import Message as _Message

from luminarycloud.tables import RectilinearTable
from luminarycloud.types import Vector3
from luminarycloud.types.adfloat import _to_ad_proto, _from_ad_proto
from luminarycloud._proto.client import simulation_pb2 as clientpb
from luminarycloud._proto.client.entity_pb2 import EntityIdentifier
import luminarycloud.params.enum._enum_wrappers as enum

from luminarycloud.params.param_wrappers._lib import ParamGroupWrapper, CodeRepr, create_unique_id

from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions_fluid_ import (
    BoundaryConditionsFluid,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions_fluid_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.komega.bc_komega_variables_ import (
    BcKomegaVariables,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.komega.bc_komega_variables_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.spalart_allmaras.bc_sa_variable_ import (
    BcSaVariable,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.spalart_allmaras.bc_sa_variable_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.komega.bc_turbulent_viscosity_and_intensity_komega_ import (
    BcTurbulentViscosityAndIntensityKomega,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.komega.bc_turbulent_viscosity_and_intensity_komega_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.komega.bc_turbulent_viscosity_ratio_and_intensity_komega_ import (
    BcTurbulentViscosityRatioAndIntensityKomega,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.komega.bc_turbulent_viscosity_ratio_and_intensity_komega_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.spalart_allmaras.bc_turbulent_viscosity_ratio_sa_ import (
    BcTurbulentViscosityRatioSa,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.spalart_allmaras.bc_turbulent_viscosity_ratio_sa_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.spalart_allmaras.bc_turbulent_viscosity_sa_ import (
    BcTurbulentViscositySa,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.spalart_allmaras.bc_turbulent_viscosity_sa_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.komega_boundary_conditions_ import (
    KomegaBoundaryConditions,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.komega_boundary_conditions_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.spalart_allmaras_boundary_conditions_ import (
    SpalartAllmarasBoundaryConditions,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence.spalart_allmaras_boundary_conditions_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence_boundary_conditions_ import (
    TurbulenceBoundaryConditions,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.turbulence_boundary_conditions_ import *


@dataclass(kw_only=True)
class Inlet(BoundaryConditionsFluid):
    """Inlet boundary condition."""

    enable_profile: bool = False
    "Turn on or off the ability to use tabulated data to define spatially varying boundary conditions."
    profile_table: Optional[RectilinearTable] = None
    "Tabulated data for spatially varying boundary conditions"
    profile_type: enum.ProfileType = enum.ProfileType.CARTESIAN_X
    "Types of boundary condition profile."
    inlet_energy: enum.InletEnergy = enum.InletEnergy.TOTAL_TEMPERATURE_INLET
    "Method of defining the inlet energy conditions."
    total_temperature: float = 300
    "Total temperature at the inlet boundary."
    total_temperature_column_index: int = 0
    "Index of the column of the table in profile_bc_data for Total Temperature"
    turbulence: TurbulenceBoundaryConditions = field(default_factory=TurbulenceBoundaryConditions)
    "Turbulence boundary conditions."

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = super()._to_proto()
        _proto.physical_boundary = enum.PhysicalBoundary.INLET.value
        _proto.profile_bc = self.enable_profile
        if self.profile_table is not None:
            if self.profile_table.table_type != _param_name_to_table_type("profile_bc_data"):
                raise TypeError("Wrong TableType used for self.profile_table")
            _proto.profile_bc_data = self.profile_table.id
        _proto.profile_type = self.profile_type.value
        _proto.inlet_energy = self.inlet_energy.value
        _proto.total_temperature.CopyFrom(_to_ad_proto(self.total_temperature))
        _proto.total_temperature_col.value = self.total_temperature_column_index
        if isinstance(self.turbulence.spalart_allmaras, BcTurbulentViscosityRatioSa):
            _proto.turbulence_specification_spalart_allmaras = clientpb.TURBULENT_VISCOSITY_RATIO_SA
            _proto.turbulent_viscosity_ratio.CopyFrom(
                _to_ad_proto(self.turbulence.spalart_allmaras.viscosity_ratio)
            )
        if isinstance(self.turbulence.spalart_allmaras, BcTurbulentViscositySa):
            _proto.turbulence_specification_spalart_allmaras = clientpb.TURBULENT_VISCOSITY_SA
            _proto.turbulent_viscosity.CopyFrom(
                _to_ad_proto(self.turbulence.spalart_allmaras.viscosity)
            )
        if isinstance(self.turbulence.spalart_allmaras, BcSaVariable):
            _proto.turbulence_specification_spalart_allmaras = clientpb.BC_SA_VARIABLE
            _proto.bc_uniform_nu_tilde.CopyFrom(
                _to_ad_proto(self.turbulence.spalart_allmaras.sa_variable)
            )
            _proto.bc_nu_tilde_col.value = self.turbulence.spalart_allmaras.sa_variable_column_index
        if isinstance(self.turbulence.komega, BcTurbulentViscosityRatioAndIntensityKomega):
            _proto.turbulence_specification_komega = (
                clientpb.BC_TURBULENT_VISCOSITY_RATIO_AND_INTENSITY_KOMEGA
            )
            _proto.turbulent_viscosity_ratio.CopyFrom(
                _to_ad_proto(self.turbulence.komega.viscosity_ratio)
            )
            _proto.turbulence_intensity.CopyFrom(_to_ad_proto(self.turbulence.komega.intensity))
        if isinstance(self.turbulence.komega, BcTurbulentViscosityAndIntensityKomega):
            _proto.turbulence_specification_komega = (
                clientpb.BC_TURBULENT_VISCOSITY_AND_INTENSITY_KOMEGA
            )
            _proto.turbulent_viscosity.CopyFrom(_to_ad_proto(self.turbulence.komega.viscosity))
            _proto.turbulence_intensity.CopyFrom(_to_ad_proto(self.turbulence.komega.intensity))
        if isinstance(self.turbulence.komega, BcKomegaVariables):
            _proto.turbulence_specification_komega = clientpb.BC_KOMEGA_VARIABLES
            _proto.bc_uniform_tke.CopyFrom(_to_ad_proto(self.turbulence.komega.tke))
            _proto.bc_uniform_omega.CopyFrom(_to_ad_proto(self.turbulence.komega.omega))
            _proto.bc_tke_col.value = self.turbulence.komega.tke_column_index
            _proto.bc_omega_col.value = self.turbulence.komega.omega_column_index
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid) -> None:
        super()._from_proto(proto)
        assert proto.physical_boundary == enum.PhysicalBoundary.INLET.value
        self.enable_profile = proto.profile_bc
        if proto.profile_bc_data != "":
            self.profile_table = RectilinearTable(
                id=proto.profile_bc_data,
                name=proto.profile_bc_data,
                table_type=_param_name_to_table_type("profile_bc_data"),
            )
        self.profile_type = enum.ProfileType(proto.profile_type)
        self.inlet_energy = enum.InletEnergy(proto.inlet_energy)
        self.total_temperature = _from_ad_proto(proto.total_temperature)
        self.total_temperature_column_index = proto.total_temperature_col.value
        if (
            proto.turbulence_specification_spalart_allmaras
            == clientpb.INVALID_TURBULENCE_SPECIFICATION_SPALART_ALLMARAS
        ):
            raise ValueError("Invalid spalart_allmaras_boundary_conditions")
        elif (
            proto.turbulence_specification_spalart_allmaras == clientpb.TURBULENT_VISCOSITY_RATIO_SA
        ):
            self.turbulence.spalart_allmaras = BcTurbulentViscosityRatioSa()
            self.turbulence.spalart_allmaras.viscosity_ratio = _from_ad_proto(
                proto.turbulent_viscosity_ratio
            )
        elif proto.turbulence_specification_spalart_allmaras == clientpb.TURBULENT_VISCOSITY_SA:
            self.turbulence.spalart_allmaras = BcTurbulentViscositySa()
            self.turbulence.spalart_allmaras.viscosity = _from_ad_proto(proto.turbulent_viscosity)
        elif proto.turbulence_specification_spalart_allmaras == clientpb.BC_SA_VARIABLE:
            self.turbulence.spalart_allmaras = BcSaVariable()
            self.turbulence.spalart_allmaras.sa_variable = _from_ad_proto(proto.bc_uniform_nu_tilde)
            self.turbulence.spalart_allmaras.sa_variable_column_index = proto.bc_nu_tilde_col.value
        if (
            proto.turbulence_specification_komega
            == clientpb.INVALID_TURBULENCE_SPECIFICATION_KOMEGA
        ):
            raise ValueError("Invalid komega_boundary_conditions")
        elif (
            proto.turbulence_specification_komega
            == clientpb.BC_TURBULENT_VISCOSITY_RATIO_AND_INTENSITY_KOMEGA
        ):
            self.turbulence.komega = BcTurbulentViscosityRatioAndIntensityKomega()
            self.turbulence.komega.viscosity_ratio = _from_ad_proto(proto.turbulent_viscosity_ratio)
            self.turbulence.komega.intensity = _from_ad_proto(proto.turbulence_intensity)
        elif (
            proto.turbulence_specification_komega
            == clientpb.BC_TURBULENT_VISCOSITY_AND_INTENSITY_KOMEGA
        ):
            self.turbulence.komega = BcTurbulentViscosityAndIntensityKomega()
            self.turbulence.komega.viscosity = _from_ad_proto(proto.turbulent_viscosity)
            self.turbulence.komega.intensity = _from_ad_proto(proto.turbulence_intensity)
        elif proto.turbulence_specification_komega == clientpb.BC_KOMEGA_VARIABLES:
            self.turbulence.komega = BcKomegaVariables()
            self.turbulence.komega.tke = _from_ad_proto(proto.bc_uniform_tke)
            self.turbulence.komega.omega = _from_ad_proto(proto.bc_uniform_omega)
            self.turbulence.komega.tke_column_index = proto.bc_tke_col.value
            self.turbulence.komega.omega_column_index = proto.bc_omega_col.value
        return None
