<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Audio Recorder</title>
        <style>
            body {
                background-color: transparent;
                margin: 0;
                padding: 0;
            }
            #toggleBtn {
                padding: 10px 20px;
                border-radius: 4px;
                border: none;
                cursor: pointer;
                background-color: #ff5f56;
                color: white;
                font-size: 16px;
            }
            #toggleBtn.recording {
                background-color: #4CAF50;
            }
        </style>
        <script>
            function sendMessageToStreamlitClient(type, data) {
                const outData = Object.assign({
                    isStreamlitMessage: true,
                    type: type,
                }, data);
                window.parent.postMessage(outData, "*");
            }

            const Streamlit = {
                setComponentReady: function() {
                    sendMessageToStreamlitClient("streamlit:componentReady", {apiVersion: 1});
                },
                setFrameHeight: function(height) {
                    sendMessageToStreamlitClient("streamlit:setFrameHeight", {height: height});
                },
                setComponentValue: function(value) {
                    sendMessageToStreamlitClient("streamlit:setComponentValue", {value: value});
                },
                RENDER_EVENT: "streamlit:render",
                events: {
                    addEventListener: function(type, callback) {
                        window.addEventListener("message", function(event) {
                            if (event.data.type === type) {
                                event.detail = event.data
                                callback(event);
                            }
                        });
                    }
                }
            }
        </script>
    </head>
    <body>
        <button id="toggleBtn">Start Recording</button>
    </body>
    <script src="https://unpkg.com/hark@1.2.0/hark.bundle.js"></script>
    <script>
        let mediaStream = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let speechEvents = null;
        let silenceTimeout = null;
        let isRecording = false;
        const toggleBtn = document.getElementById('toggleBtn');
        
        // Initialize the component
        Streamlit.setComponentReady();
        Streamlit.setFrameHeight(60); // Just enough for the button
        
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const base64String = reader.result.split(',')[1];
                    resolve(base64String);
                };
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        async function handleRecordingStopped() {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            const base64Data = await blobToBase64(audioBlob);
            
            // Send the audio data back to Streamlit
            Streamlit.setComponentValue({
                audioData: base64Data,
                status: 'stopped'
            });
        }
        
        function onRender(event) {
            // Get params passed from Python
            const args = event.detail.args;
            window.harkConfig = {
                interval: args.interval || 50,
                threshold: args.threshold || -60,
                play: args.play !== undefined ? args.play : false,
                silenceTimeout: args.silenceTimeout || 1500
            };
            
            console.log("Hark configuration:", window.harkConfig);
        }
        
        // Listen for configuration parameters from Python
        Streamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender);
        
        toggleBtn.addEventListener('click', async () => {
            if (!isRecording) {
                // Start recording
                try {
                    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(mediaStream);
                    audioChunks = [];
                    
                    mediaRecorder.ondataavailable = event => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        handleRecordingStopped().catch(err => {
                            console.error('Error handling recording:', err);
                            Streamlit.setComponentValue({
                                error: 'Failed to process recording'
                            });
                        });
                    };
                    
                    // Initialize silence detection with config parameters
                    speechEvents = hark(mediaStream, {
                        interval: window.harkConfig.interval,
                        threshold: window.harkConfig.threshold,
                        play: window.harkConfig.play
                    });
                    
                    // When speech stops
                    speechEvents.on('stopped_speaking', () => {
                        silenceTimeout = setTimeout(() => {
                            if (mediaRecorder && mediaRecorder.state === 'recording') {
                                mediaRecorder.stop();
                                
                                // Start new recording if still in recording mode
                                if (isRecording) {
                                    audioChunks = [];
                                    mediaRecorder = new MediaRecorder(mediaStream);
                                    mediaRecorder.ondataavailable = event => {
                                        if (event.data.size > 0) {
                                            audioChunks.push(event.data);
                                        }
                                    };
                                    mediaRecorder.onstop = () => {
                                        handleRecordingStopped().catch(err => {
                                            console.error('Error handling recording:', err);
                                        });
                                    };
                                    mediaRecorder.start();
                                }
                            }
                        }, window.harkConfig.silenceTimeout);
                    });
                    
                    // Clear timeout when speech starts
                    speechEvents.on('speaking', () => {
                        if (silenceTimeout) {
                            clearTimeout(silenceTimeout);
                            silenceTimeout = null;
                        }
                    });
                    
                    mediaRecorder.start();
                    isRecording = true;
                    toggleBtn.classList.add('recording');
                    toggleBtn.textContent = 'Stop Recording';
                    
                } catch (err) {
                    console.error('Error accessing microphone:', err);
                    Streamlit.setComponentValue({
                        error: err.message
                    });
                }
            } else {
                // Stop recording
                isRecording = false;
                toggleBtn.classList.remove('recording');
                toggleBtn.textContent = 'Start Recording';
                
                if (speechEvents) {
                    speechEvents.stop();
                    speechEvents = null;
                }
                
                if (silenceTimeout) {
                    clearTimeout(silenceTimeout);
                    silenceTimeout = null;
                }
                
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }
            }
        });
    </script>
</html>