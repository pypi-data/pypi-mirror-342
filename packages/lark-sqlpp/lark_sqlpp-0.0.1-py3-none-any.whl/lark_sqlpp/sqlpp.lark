start: statement_sequence

WHITESPACE: (" " | /\t/ | /\n/ | /\r/ )+
%ignore WHITESPACE

statement_sequence: statement ( ";" statement )* ";"?

statement: dcl_statement
	| ddl_statement
	| dml_statement 
	| dql_statement 
	| utility_statement

ddl_statement: create_statement
	| drop_statement
	| other_statement

create_statement: create_scope
	| create_collection
	| create_primary_index
	| create_index
	| create_function
	| create_sequence

drop_statement: drop_scope
	| drop_collection
	| drop_primary_index
	| drop_index
	| drop_function

other_statement: alter_index
	| build_index
	| execute_function

create_scope: "CREATE"i "SCOPE"i ( namespace_ref ":" )? bucket_ref "." scope_ref if_not_exists?

if_not_exists: "IF"i "NOT"i "EXISTS"i

create_collection: "CREATE"i "COLLECTION"i ( ( namespace_ref ":" )? bucket_ref "." scope_ref "." )? \
	collection_ref if_not_exists?

drop_scope: "DROP"i "SCOPE"i ( namespace_ref ":")? bucket_ref "." scope_ref if_exists?

if_exists: "IF"i "EXISTS"i

drop_collection: "DROP"i "COLLECTION"i \
	( ( namespace_ref ":")? bucket_ref "." scope_ref "." )? \
	collection_ref if_exists?

create_primary_index: "CREATE"i "PRIMARY"i "INDEX"i index_name? ( "IF"i "NOT"i "EXISTS"i )? "ON"i \
	keyspace_ref index_using? index_with?

index_using: "USING"i "GSI"i

index_with: "WITH"i expr

create_index: "CREATE"i "INDEX"i index_name if_not_exists? "ON"i keyspace_ref \
	LPAREN index_key lead_key_attribs? ( ( "," index_key key_attribs? )+ )? RPAREN \
	index_partition? where_clause? index_using? index_with?

index_key: expr | array_expr

lead_key_attribs: (index_order include_missing?) | (include_missing index_order?)

key_attribs: index_order

include_missing: "INCLUDE"i "MISSING"i

index_order: "ASC"i | "DESC"i

array_expr: full_array_expr | simple_array_expr

full_array_expr: ( "ALL"i | "DISTINCT"i ) "ARRAY"i expr \
	"FOR"i var ( "IN"i | "WITHIN"i ) expr \
	( "," var ( "IN"i | "WITHIN"i ) expr )* ("WHEN"i cond)? "END"i \

simple_array_expr: ( "ALL"i | "DISTINCT"i ) expr

pairs_function: "PAIRS"i LPAREN ( "SELF"i | index_key_object ) RPAREN

index_key_object: expr

index_partition: "PARTITION"i "BY"i "HASH"i LPAREN partition_key_expr \
	( "," partition_key_expr )* RPAREN

partition_key_expr: expr

alter_index: "ALTER"i "INDEX"i ( ( index_path "." index_name ) | ( index_name "ON"i keyspace_ref ) \
	index_using? index_with )

build_index: "BUILD"i "INDEX"i "ON"i keyspace_ref LPAREN index_term ( "," index_term )* RPAREN index_using?

index_term: index_name | subquery_expr

drop_primary_index: "DROP"i "PRIMARY"i "INDEX"i if_exists? "ON"i keyspace_ref index_using?

drop_index: "DROP"i "INDEX"i ( ( index_path "." index_name if_exists? ) | \
    index_name if_exists? "ON"i keyspace_ref ) index_using?

index_path: keyspace_full | keyspace_prefix | keyspace_partial

keyspace_full: namespace_ref ":" bucket_ref "." scope_ref "." collection_ref

keyspace_prefix: ( namespace_ref ":" )? bucket_ref

create_function: create_function_inline | create_function_external

create_function_inline: "CREATE"i ( "OR"i "REPLACE"i )? "FUNCTION"i function_ref LPAREN params? RPAREN if_not_exists? \
	( ( LBRACE body RBRACE ) | ( "LANGUAGE"i "INLINE"i "AS"i body ) )

create_function_external: "CREATE"i ( "OR"i "REPLACE"i )? "FUNCTION"i function_ref LPAREN params? RPAREN if_not_exists? \
	"LANGUAGE"i "JAVASCRIPT"i "AS"i obj "AT"i


function_ref: ( namespace_ref ":" ( bucket_ref "." scope_ref "." )? )? identifier_ref

params: ( identifier_or_star ( "," identifier_or_star )* ) | "..."

body: ( expr | let_clause )*

obj: json_object

create_sequence: "CREATE"i "SEQUENCE"i ( \
    ( sequence if_not_exists? )
        | ( if_not_exists? sequence ) ) ( create_sequence_options | sequence_with )?

sequence: ( ( namespace_ref ":" )? bucket_ref "." scope_ref "." )? identifier_ref

create_sequence_options: ( start_with
    | increment_by
    | maxvalue
    | minvalue
    | cycle
    | cache )*

start_with: "START"i "WITH"i nbr

increment_by: "INCREMENT"i "BY"i nbr

maxvalue: ( "MAXVALUE"i nbr ) | ( "NO"i "MAXVALUE"i )

minvalue: ( "MINVALUE"i nbr ) | ( "NO"i "MINVALUE"i )

cycle: "NO"i? "CYCLE"i

cache: ( "CACHE"i nbr ) | ( "NO"i "CACHE"i )

sequence_with: "WITH"i expr

drop_function: "DROP"i "FUNCTION"i function_ref if_exists?

execute_function: "EXECUTE"i "FUNCTION"i function_ref LPAREN ( expr ( "," expr )* )? RPAREN

dml_statement: delete_statement
	| insert_statement
	| merge_statement
	| update_statement
	| upsert_statement

delete_statement: "DELETE"i "FROM"i target_keyspace use_keys_clause? where_clause? returning_clause?

insert_statement: "INSERT"i "INTO"i target_keyspace ( insert_values | insert_select )

insert_values: ( LPAREN "PRIMARY"i? "KEY"i "," "VALUE"i ( "," options )? RPAREN )? values_clause

values_clause: "VALUES"i LPAREN key_expr "," value_expr ( "," "OPTIONS"i )? RPAREN  \
	( "," "VALUES"i? LPAREN key_expr "," value_expr ( "," "OPTIONS"i )? RPAREN )*


insert_select: LPAREN "PRIMARY"i? "KEY"i key_expr ( "," "VALUE"i value_expr )? \
	( "," "OPTIONS"i options )? RPAREN select_statement


options: obj

merge_statement: "MERGE"i "INTO"i ( ansi_merge | lookup_merge ) limit_clause? returning_clause?

ansi_merge: target_keyspace use_index_clause "USING"i ansi_merge_source \
	ansi_merge_predicate ansi_merge_actions

ansi_merge_source: ( merge_source_keyspace | merge_source_subquery | merge_source_expr ) \
	ansi_join_hints?

ansi_merge_predicate: "ON"i expr

ansi_merge_actions: merge_update? merge_delete? ansi_merge_insert?

ansi_merge_insert: "WHEN"i "NOT"i "MATCHED"i "THEN"i "INSERT"i LPAREN "KEY"i? key_expr  \
	( "," "VALUE"i? value_expr )? ( "," "OPTIONS"i? options )? RPAREN where_clause?


lookup_merge: target_keyspace "USING"i lookup_merge_source lookup_merge_predicate \
	lookup_merge_actions

lookup_merge_source: ( merge_source_keyspace use_clause? ) 
	| merge_source_subquery
	| merge_source_expr

lookup_merge_predicate: "ON"i "PRIMARY"i? "KEY"i expr

lookup_merge_actions: merge_update? merge_delete? lookup_merge_insert?

lookup_merge_insert: "WHEN"i "NOT"i "MATCHED"i "THEN"i "INSERT"i expr where_clause?

merge_source_keyspace: keyspace_ref ( "AS"i? alias )?

merge_source_subquery: subquery_expr "AS"i? alias

merge_source_expr: expr ( "AS"i? alias )?

merge_update: "WHEN"i "MATCHED"i "THEN"i "UPDATE"i set_clause? unset_clause? where_clause?

merge_delete: "WHEN"i "MATCHED"i "THEN"i "DELETE"i where_clause?

update_statement: "UPDATE"i target_keyspace use_keys_clause? set_clause? unset_clause? \
	where_clause? limit_clause? returning_clause?

upsert_statement: "UPSERT"i "INTO"i target_keyspace ( insert_values | insert_select ) \
	returning_clause?

target_keyspace: keyspace_ref ( "AS"i? alias )?

returning_clause: "RETURNING"i ( ( result_expr ( "," result_expr )* ) | \
	( ( "RAW"i | "ELEMENT"i | "VALUE"i ) expr ) )


set_clause: "SET"i ( path "=" expr update_for? ) \
	( "," ( path "=" expr update_for? ) )*

unset_clause: "UNSET"i path update_for? ( "," path update_for? )*

update_for: ( "FOR"i ( name_var ":" )? var ( "IN"i | "WITHIN"i ) path \
	( "," ( name_var ":" )? var ( "IN"i | "WITHIN"i ) path )* )+ \
	( "WHEN"i cond )? "END"i


key_expr: expr

value_expr: expr

dql_statement: select_statement
    | infer_statement
    | update_statistics

select_statement: select_term ( set_op select_term )* order_by_clause? limit_clause? offset_clause?

select_term: subselect | LPAREN select_statement RPAREN

subselect: select_from | from_select

select_from: with_clause? select_clause from_clause? let_clause? where_clause? group_by_clause? window_clause?

from_select: with_clause? from_clause let_clause? where_clause? group_by_clause? window_clause? select_clause

set_op: ( "UNION"i | "INTERSECT"i | "EXCEPT"i ) "ALL"i?

with_clause: "WITH"i alias "AS"i LPAREN ( select_statement | expr ) RPAREN \
    ( "," alias "AS"i LPAREN ( select_statement | expr ) RPAREN )*

alias: identifier_ref

select_clause: "SELECT"i hint_comment? projection

projection: ( "ALL"i | "DISTINCT"i )? ( result_expr ( "," result_expr )* | \
	( "RAW"i | "ELEMENT"i | "VALUE"i ) expr ( "AS"i? alias )? )

result_expr: ( ( path "." )? "*") | expr ( "AS"i? alias )?

path: identifier_ref ( LBRACKET expr RBRACKET )* ( "." identifier_ref ( LBRACKET expr RBRACKET )* )*

from_clause: "FROM"i from_terms

from_terms: ( from_keyspace | from_subquery | from_generic ) \
	( join_clause | nest_clause | unnest_clause )* comma_separated_join*

from_keyspace: keyspace_ref ( "AS"i? alias )? use_clause?

keyspace_ref: keyspace_path | keyspace_partial

keyspace_path: ( namespace_ref ":" )? bucket_ref ( "." scope_ref "." collection_ref )?

keyspace_partial: collection_ref

namespace_ref: identifier_ref

bucket_ref: identifier_ref

scope_ref: identifier_ref

collection_ref: identifier_ref

from_subquery: subquery_expr "AS"i? alias

subquery_expr: LPAREN select_statement RPAREN

from_generic: expr ( "AS"i? alias)?

join_clause: ansi_join_clause | lookup_join_clause | index_join_clause

ansi_join_clause: ansi_join_type? "JOIN"i ansi_join_rhs ansi_join_predicate

ansi_join_type: "INNER"i | ( "LEFT"i | "RIGHT"i ) "OUTER"i?

ansi_join_rhs: rhs_keyspace | rhs_subquery | rhs_generic

rhs_keyspace: keyspace_ref ( "AS"i? alias )? ansi_join_hints?

rhs_subquery: subquery_expr "AS"i? alias

rhs_generic: expr ( "AS"i? alias )?

ansi_join_hints: use_hash_hint | use_nl_hint | multiple_hints

use_hash_hint: "USE"i use_hash_term

use_hash_term: "HASH"i LPAREN ( "BUILD"i | "PROBE"i ) RPAREN

use_nl_hint: "USE"i use_nl_term

use_nl_term: "NL"i

multiple_hints: "USE"i ( ( ansi_hint_terms other_hint_terms ) | ( other_hint_terms ansi_hint_terms ) )

ansi_hint_terms: use_hash_term | use_nl_term

other_hint_terms: use_index_term | use_keys_term

ansi_join_predicate: "ON"i expr

lookup_join_clause: lookup_join_type? "JOIN"i lookup_join_rhs lookup_join_predicate

lookup_join_type: "INNER"i | ( "LEFT"i "OUTER"i? )

lookup_join_rhs: keyspace_ref ( "AS"i? alias )?

lookup_join_predicate: "ON"i "PRIMARY"i? "KEYS"i expr

index_join_clause: index_join_type? "JOIN"i index_join_rhs index_join_predicate

index_join_type: "INNER"i | ( "LEFT"i "OUTER"i? )

index_join_rhs: keyspace_ref ( "AS"i? alias )?

index_join_predicate: "ON"i "PRIMARY"i? "KEY"i expr "FOR"i alias

comma_separated_join: "," ( rhs_keyspace | rhs_subquery | rhs_generic )

nest_clause: ansi_nest_clause | lookup_nest_clause | index_nest_clause

ansi_nest_clause: ansi_nest_type? "NEST"i ansi_nest_rhs ansi_nest_predicate

ansi_nest_type: "INNER"i | ( "LEFT"i "OUTER"i? )

ansi_nest_rhs: keyspace_ref ( "AS"i? alias )?

ansi_nest_predicate: "ON"i expr

lookup_nest_clause: lookup_nest_type? "NEST"i lookup_nest_rhs lookup_nest_predicate

lookup_nest_type: "INNER"i | ( "LEFT"i "OUTER"i? )

lookup_nest_rhs: keyspace_ref ( "AS"i? alias )?

lookup_nest_predicate: "ON"i "KEYS"i expr

index_nest_clause: index_nest_type? "NEST"i index_nest_rhs index_nest_predicate

index_nest_type: "INNER"i | ( "LEFT"i "OUTER"i? )

index_nest_rhs: keyspace_ref ( "AS"i? alias )?

index_nest_predicate: "ON"i "KEY"i expr "FOR"i alias

unnest_clause: unnest_type? ( "UNNEST"i | "FLATTEN"i ) expr ( "AS"i? alias )?

unnest_type: "INNER"i | ( "LEFT"i "OUTER"i? )

use_clause: use_keys_clause | use_index_clause

use_keys_clause: "USE"i use_keys_term

use_keys_term: "PRIMARY"i? "KEYS"i expr

use_index_clause: "USE"i use_index_term

use_index_term: "INDEX"i LPAREN index_ref ( "," index_ref )* RPAREN

index_ref: index_name? index_type?

index_name: identifier_ref

index_type: "USING"i ( "GSI"i | "FTS"i )

let_clause: "LET"i alias "=" expr ( "," alias "=" expr )*

where_clause: "WHERE"i cond

cond: expr

group_by_clause: "GROUP"i "BY"i group_term ( "," group_term )* \
	letting_clause? having_clause? | letting_clause

group_term: expr ( "AS"i? alias )?

letting_clause: "LETTING"i alias "=" expr ( "," alias "=" expr )*

having_clause: "HAVING"i cond

window_clause: "WINDOW"i window_declaration ( "," window_declaration )*

window_declaration: window_name "AS"i LPAREN window_definition RPAREN

window_name: identifier_ref

window_definition: window_ref? window_partition_clause? window_order_clause? window_frame_clause?

window_ref: identifier_ref

window_partition_clause: "PARTITION"i "BY"i expr ( "," expr )*

window_order_clause: "ORDER"i "BY"i ordering_term ( "," ordering_term )*

window_frame_clause: ( "ROWS"i | "RANGE"i | "GROUPS"i ) window_frame_extent window_frame_exclusion?

window_frame_extent: ( "UNBOUNDED"i "PRECEDING"i )
	| ( "CURRENT"i "ROW"i )
	| ( "BETWEEN"i ( ( "UNBOUNDED"i "PRECEDING"i )
		| ( "CURRENT"i "ROW"i )
		| ( "PRECEDING"i | "FOLLOWING"i ) \
	) )

window_frame_exclusion: "EXCLUDE"i ( ( "CURRENT"i "ROW"i ) | "GROUP"i | "TIES"i | ( "NO"i "OTHERS"i ) )

order_by_clause: "ORDER"i "BY"i ordering_term ( "," ordering_term )*

ordering_term: expr ( "ASC"i | "DESC"i )? ( "NULLS"i ( "FIRST"i | "LAST"i ) )?

limit_clause: "LIMIT"i expr

offset_clause: "OFFSET"i expr

hint_comment: block_hint_comment | line_hint_comment

block_hint_comment: "/*+" hints "*/"

line_hint_comment: "--+" hints

hints: simple_hint_sequence | json_hint_object

simple_hint_sequence: simple_hint+

simple_hint: ordered_hint_simple
    | gsi_hint_simple
    | fts_hint_simple
    | hash_hint_simple
    | nl_hint_simple

ordered_hint_simple: "ORDERED"i

gsi_hint_simple: "INDEX"i LPAREN keyspace_statement RPAREN

keyspace_statement: "KEYSPACE"i identifier_ref

fts_hint_simple: "INDEX_FTS"i LPAREN keyspace_statement RPAREN

nl_hint_simple: "USE_NL"i LPAREN ( keyspace_statement )+ RPAREN

hash_hint_simple: "USE_HASH"i LPAREN ( keyspace_statement ( "/" ( "BUILD"i | "PROBE"i ) )? )+ RPAREN

json_hint_object: LBRACE json_hint ( "," json_hint )* RBRACE

json_hint: ordered_hint_json
    | gsi_hint_json
    | fts_hint_json
    | hash_hint_json
    | nl_hint_json

ordered_hint_json: "\"ORDERED\"" ":" "TRUE"i

gsi_hint_json: "\"INDEX\"" ":" ( index_array | index_object )

fts_hint_json: "\"INDEX_FTS\"" ":" ( index_array | index_object )

nl_hint_json: "\"USE_NS\"" ":" ( keyspace_array | keyspace_object )

hash_hint_json: "\"USE_HASH\"" ":" ( hash_array | hash_object )

index_array: LBRACKET index_object ( "," index_object )* RBRACKET

index_object: LBRACE keyspace_property "," indexes_property RBRACE

indexes_property: "\"INDEXES\"" ":" ( "NULL"i
                                        | ( "\"" index "\"" )
                                        | ( LBRACKET "\"" index "\"" RBRACKET ( "," "\"" index "\"" )* RBRACKET ) \
                                    )

index: index_ref

keyspace_array: LBRACKET keyspace_object ( "," keyspace_object )* RBRACKET

keyspace_object: LBRACE keyspace_property RBRACE

keyspace_property: ( "\"KEYSPACE\"" | "\"ALIAS\"" ) ":" "\"" keyspace_statement "\""

hash_array: LBRACKET hash_object ( "," hash_object )* RBRACKET

hash_object: LBRACE keyspace_property ( "," option_property )? RBRACE

option_property: "\"OPTION\"" ":" ( "\"BUILD\"" | "\"PROBE\"" | "NULL"i )

expr: ( \
        ( \
            function_call
            | path
            | json_value
            | literal
            | named_arg
            | nested_expr
            | new_array_expr
            | ( LPAREN expr RPAREN )
            | subquery_expr \
        ) ( \
            comparison_term
            | arithmetic_term
            | concatenation_term
            | logical_term
            | collection_expr \
        )* \
    ) | case_expr | ( LPAREN expr RPAREN )

literal: str | nbr | bool | "NULL"i | "MISSING"i

nbr: digit+ ( "." digit+ )? ( "E"i ( "+" | "-" ) digit+ )?

digit: "0".."9"

str: double_quoted_string | single_quoted_string

double_quoted_string: "\"" double_quoted_string_character* "\""

single_quoted_string: "'" single_quoted_string_character* "'"

double_quoted_string_character: ( escape_sequence | "\\\"" | string_char )

single_quoted_string_character: ( escape_sequence | "\\'" | string_char )

escape_sequence: /\\[nrt\\]/ | /\\u[0-9a-fA-F]{4}/

string_char: /./

bool: "TRUE"i | "FALSE"i

identifier_or_star: identifier_ref | "*"

fn_names: FUNCS | grammar_funcs

FUNCS: "ABS"i
    | "ACOS"i
    | "ARRAY_APPEND"i
    | "ARRAY_AVG"i
    | "ARRAY_CONCAT"i
    | "ARRAY_CONTAINS"i
    | "ARRAY_COUNT"i
    | "ARRAY_DISTINCT"i
    | "ARRAY_FLATTEN"i
    | "ARRAY_IFNULL"i
    | "ARRAY_INSERT"i
    | "ARRAY_INTERSECT"i
    | "ARRAY_LENGTH"i
    | "ARRAY_MAX"i
    | "ARRAY_MIN"i
    | "ARRAY_POSITION"i
    | "ARRAY_PREPEND"i
    | "ARRAY_PUT"i
    | "ARRAY_RANGE"i
    | "ARRAY_REMOVE"i
    | "ARRAY_REPEAT"i
    | "ARRAY_REPLACE"i
    | "ARRAY_REVERSE"i
    | "ARRAY_SORT"i
    | "ARRAY_STAR"i
    | "ARRAY_SUM"i
    | "ARRAY_SYMDIFF"i
    | "ARRAY_SYMDIFF1"i
    | "ARRAY_SYMDIFFN"i
    | "ARRAY_UNION"i
    | "ASIN"i
    | "ATAN"i
    | "ATAN2"i
    | "AVG"i
    | "CEIL"i
    | "CLOCK_LOCAL"i
    | "CLOCK_MILLIS"i
    | "CLOCK_STR"i
    | "CLOCK_TZ"i
    | "CLOCK_UTC"i
    | "CONCAT"i
    | "CONTAINS"i
    | "COS"i
    | "COUNT"i
    | "DATE_ADD_MILLIS"i
    | "DATE_DIFF_STR"i
    | "DATE_FORMAT_STR"i
    | "DATE_PART_MILLIS"i
    | "DATE_PART_STR"i
    | "DATE_RANGE_MILLIS"i
    | "DATE_RANGE_STR"i
    | "DATE_TRUNC_MILLIS"i
    | "DATE_TRUNC_STR"i
    | "DECODE_JSON"i
    | "DEGREES"i
    | "DURATION_TO_STR"i
    | "ENCODE_JSON"i
    | "ENCODED_SIZE"i
    | "EXP"i
    | "FLOOR"i
    | "GREATEST"i
    | "IF_INF"i
    | "IF_MISSING"i
    | "IF_MISSING_OR_NULL"i
    | "IF_NAN"i
    | "IF_NAN_OR_INF"i
    | "IF_NULL"i
    | "IFINF"i
    | "IFMISSING"i
    | "IFMISSINGORNULL"i
    | "IFNAN"i
    | "IFNANORINF"i
    | "IFNULL"i
    | "INITCAP"i
    | "IS_ARRAY"i
    | "IS_ATOM"i
    | "IS_BOOL"i
    | "IS_BOOLEAN"i
    | "IS_NUM"i
    | "IS_NUMBER"i
    | "IS_OBJ"i
    | "IS_OBJECT"i
    | "IS_STR"i
    | "IS_STRING"i
    | "ISARRAY"i
    | "LEAST"i
    | "LENGTH"i
    | "LN"i
    | "LOG"i
    | "LOWER"i
    | "LTRIM"i
    | "MAX"i
    | "META"i
    | "MILLIS"i
    | "MILLIS_TO_LOCAL"i
    | "MILLIS_TO_STR"i
    | "MILLIS_TO_TZ"i
    | "MILLIS_TO_UTC"i
    | "MILLIS_TO_ZONE_NAME"i
    | "MIN"i
    | "MISSING_IF"i
    | "MISSINGIF"i
    | "NOW_LOCAL"i
    | "NOW_MILLIS"i
    | "NOW_STR"i
    | "NOW_TZ"i
    | "NOW_UTC"i
    | "NULL_IF"i
    | "NULLIF"i
    | "OBJECT_ADD"i
    | "OBJECT_CONCAT"i
    | "OBJECT_INNER_VALUES"i
    | "OBJECT_LENGTH"i
    | "OBJECT_NAMES"i
    | "OBJECT_PAIRS"i
    | "OBJECT_PUT"i
    | "OBJECT_REMOVE"i
    | "OBJECT_RENAME"i
    | "OBJECT_REPLACE"i
    | "OBJECT_UNWRAP"i
    | "OBJECT_VALUES"i
    | "PAIRS"i
    | "PI"i
    | "POSINFIF"i
    | "POSITION"i
    | "POWER"i
    | "RADIANS"i
    | "RANDOM"i
    | "REGEXP_CONTAINS"i
    | "REGEXP_LIKE"i
    | "REGEXP_POSITION"i
    | "REGEXP_REPLACE"i
    | "REPEAT"i
    | "REPLACE"i
    | "REVERSE"i
    | "ROUND"i
    | "RTRIM"i
    | "SIGN"i
    | "SIN"i
    | "SPLIT"i
    | "SQRT"i
    | "STR_TO_DURATION"i
    | "STR_TO_MILLIS"i
    | "STR_TO_TZ"i
    | "STR_TO_UTC"i
    | "STR_TO_ZONE_NAME"i
    | "SUBSTR"i
    | "SUM"i
    | "TAN"i
    | "TITLE"i
    | "TO_ARRAY"i
    | "TO_ATOM"i
    | "TO_BOOL"i
    | "TO_BOOLEAN"i
    | "TO_NUM"i
    | "TO_NUMBER"i
    | "TO_OBJ"i
    | "TO_OBJECT"i
    | "TO_STR"i
    | "TO_STRING"i
    | "TOARRAY"i
    | "TOATOM"i
    | "TOBOOL"i
    | "TOBOOLEAN"i
    | "TONUM"i
    | "TONUMBER"i
    | "TOOBJ"i
    | "TOOBJECT"i
    | "TOSTR"i
    | "TOSTRING"i
    | "TRIM"i
    | "TRUNC"i
    | "TYPE"i
    | "TYPENAME"i
    | "UPPER"i
    | "UUID"i
    | "WEEKDAY_MILLIS"i
    | "WEEKDAY_STR"i

grammar_funcs: "TYPE"i | "TITLE"i | "SUM"i

named_arg: "$" IDENTIFIER

IDENTIFIER: /[a-zA-Z_][0-9a-zA-Z_\-$]*/

identifier_ref: IDENTIFIER | grammar_funcs | escaped_identifier

escaped_identifier: BACKTICK ( IDENTIFIER | grammar_funcs ) BACKTICK

arithmetic_term: ( "+" expr )
    | ( "*" expr )
    | ( "/" expr )
    | ( "%" expr )
    | ( "-" expr )

comparison_term: relational_expr
    | between_expr
    | like_expr
    | is_expr

relational_expr: ( "==" expr )
    | ( "=" expr )
    | ( "!=" expr )
    | ( "<>" expr )
    | ( ">" expr )
    | ( ">=" expr )
    | ( "<" expr )
    | ( "<=" expr )

between_expr: "NOT"i? "BETWEEN"i expr "AND"i expr

like_expr: "NOT"i? "LIKE"i expr

is_expr: "IS"i "NOT"i? ( "NULL"i | "MISSING"i | "VALUED"i )

concatenation_term: "||" expr

logical_term: and_expr | or_expr | not_expr

and_expr: "AND"i cond

or_expr: "OR"i cond

not_expr: "NOT"i cond

case_expr: simple_case_expr | searched_case_expr

simple_case_expr: "CASE"i expr ( "WHEN"i expr "THEN"i expr )+ ( "ELSE"i expr )? "END"i

searched_case_expr: "CASE"i ( "WHEN"i cond "THEN"i expr)+ ( "ELSE"i expr )? "END"i

collection_expr: exists_expr | in_expr | within_expr | range_cond

exists_expr: "EXISTS"i expr

in_expr: "NOT"i? "IN"i expr

within_expr: "NOT?" "WITHIN"i expr

range_cond: ( ( "ANY"i | "SOME"i ) ( "AND"i "EVERY"i )? | "EVERY"i ) range_expr "SATISFIES"i cond "END"i

range_expr: ( name_var ":" )? var ( "IN"i | "WITHIN"i ) expr \
    ( "," ( name_var ":" )? var ( "IN"i | "WITHIN"i ) expr )*

var: identifier_ref

name_var: identifier_ref

new_array_expr: LBRACKET ( expr ( "," expr )* )? RBRACKET

nested_expr: field_expr | element_expr | slice_expr

field_expr: "." ( identifier_ref | ( ( escaped_identifier | ( LBRACKET expr RBRACKET ) ) "i"i? ) )

element_expr: LBRACKET expr RBRACKET

slice_expr: LBRACKET expr ":" expr? RBRACKET

function_call: ( builtin_function
                    | ordinary_function
                    | aggregate_function
                    | window_function ) ( "." path )?

function_name: identifier_ref

aggregate_function_name: FUNCS | "TYPE"i | identifier_ref

window_function_name: FUNCS | "TYPE"i | identifier_ref

ordinary_function: function_name LPAREN ( expr ( "," expr )* )? RPAREN

builtin_function: ( FUNCS | "TYPE"i ) LPAREN ( expr ( "," expr )* )? RPAREN

aggregate_function: aggregate_function_name LPAREN \
    ( ( aggregate_quantifier? expr ) | ( ( path "." )? "*" ) ) RPAREN \
    filter_clause? over_clause?

aggregate_quantifier: "ALL"i | "DISTINCT"i

filter_clause: "FILTER"i LPAREN "WHERE"i cond RPAREN

window_function: window_function_name LPAREN window_function_arguments RPAREN \
    window_function_options? over_clause

window_function_arguments: ( expr ("," expr ( "," expr )? )? )?

window_function_options: nthval_from? nulls_treatment?

nthval_from: "FROM"i ( "FIRST"i | "LAST"i )

nulls_treatment: ( "RESPECT"i | "IGNORE"i ) "NULLS"i

over_clause: "OVER"i ( ( LPAREN window_definition RPAREN ) | window_ref )

comment: block_comment

block_comment: "/*" ( "\r"i )* "*/"

tcl_statement: begin_transaction
    | set_transaction
    | savepoint_statement
    | rollback_transaction
    | commit_transaction

begin_transaction: ( "BEGIN"i | "START"i ) ( "WORK"i | "TRAN"i | "TRANSACTION"i ) \
    ( "ISOLATION"i "LEVEL"i "READ"i "COMMITTED"i )?

set_transaction: "SET"i "TRANSACTION"i "ISOLATION"i "LEVEL"i "READ"i "COMMITTED"i

savepoint_statement: "SAVEPOINT"i savepointname

rollback_transaction: "ROLLBACK"i ( "WORK"i | "TRAN"i | "TRANSACTION"i )?

commit_transaction: "COMMIT"i ( "WORK"i | "TRAN"i | "TRANSACTION"i )?

savepointname: identifier_ref

utility_statement: advise_statement | explain_statement

advise_statement: "ADVISE"i "INDEX"i? ( select_statement
    | update_statement
    | delete_statement
    | merge_statement )

explain_statement: "INFER"i ( "COLLECTION"i | "KEYSPACE"i )? keyspace_ref ( "WITH"i options )?

infer_statement: "INFER"i ( "COLLECTION"i | "KEYSPACE"i )? keyspace_ref ( "WITH"i options )?

name: identifier_ref

parameters: array_expr

update_statistics: update_statistics_expr
    | update_statistics_index
    | update_statistics_delete
    | update_statistics_indexes

update_statistics_expr: ( ( "UPDATE"i "STATISTICS"i "FOR"i? ) | ( "ANALYZE"i ( "KEYSPACE"i | "COLLECTION"i )? ) ) \
    keyspace_ref LPAREN index_key ( "," index_key )* RPAREN index_with?

update_statistics_index: ( ( "UPDATEi" "STATISTICS"i "FOR"i? ) | "ANALYZE"i ) \
    index_clause index_using? index_with? 

index_clause: "INDEX"i ( ( index_path "." index_name ) | ( index_name "ON"i keyspace_ref ) )

update_statistics_indexes: ( ( "UPDATE"i "STATISTICS"i "FOR"i? ) | ( "ANALYZE"i ( "KEYSPACE"i | "COLLECTION"i )? ) ) \
    keyspace_ref indexes_clause index_using? index_with?

indexes_clause: "INDEX"i ( ( LPAREN ( ( index_name ( "," index_name )* ) | subquery_expr ) RPAREN ) | "ALL"i )

update_statistics_delete: ( ( "UPDATE"i "STATISTICS"i "FOR"i? ) | ( "ANALYZE"i ( "KEYSPACE"i | "COLLECTION"i )? ) ) \
    keyspace_ref delete_clause

delete_clause: "DELETE"i ( delete_expr | delete_all )

delete_expr: "STATISTICS"i? LPAREN index_key ( "," index_key )* RPAREN

delete_all: "ALL"i | "STATISTICS"i

dcl_statement: grant_statement | revoke_statement

grant_statement: "GRANT"i role ( "," role )* ( "ON"i keyspace_ref ( "," keyspace_ref )* )? "TO"i user ( "," user )*

revoke_statement: "REVOKE"i role ( "," role )* ( "ON"i keyspace_ref ( "," keyspace_ref )* )? \
    "FROM"i user ( "," user )*

role: identifier_ref

user: identifier_ref

json_value: json_object | json_array

json_array: LBRACKET ( expr ( "," expr )* )? RBRACKET

json_object: LBRACE ( json_field ( "," json_field )* )? RBRACE

json_field: str ":" expr

LBRACKET: "["
RBRACKET: "]"
LBRACE: "{"
RBRACE: "}"
BACKTICK: "`"
LPAREN: "("
RPAREN: ")"
