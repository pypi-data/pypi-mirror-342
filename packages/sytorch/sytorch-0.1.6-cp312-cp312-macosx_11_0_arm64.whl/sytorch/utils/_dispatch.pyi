from _typeshed import Incomplete
from collections.abc import Generator
from types import FunctionType as FunctionType, GenericAlias as GenericAlias
from typing import Any, Callable, Generic, Iterable, Iterator, Protocol, TypeAlias, TypeGuard, TypeVar, overload

DispatchParam = type
DispatchArg = type

def normalize_types(*typs) -> Iterator[type]: ...
def generic_type_check(inst, typ, typ_params) -> None: ...
def iter_type_args(typ_args: Iterable[type], exclude=...): ...
def generic_type_check_args(typ_args: Iterable[type], typ_params: Iterable[type]) -> bool: ...
def resolve_argument_type(arg): ...
def fallback_argument_type(typ, exclude=...) -> Generator[Incomplete, Incomplete]: ...

Param: TypeAlias
DispatchSpec: TypeAlias

class DispatcherError(Exception): ...
T = TypeVar('T')

class Dispatched(Generic[T]):
    def __new__(cls, typ: type[T]) -> type[T]: ...

class Dispatcher(Generic[T]):
    __func__: T
    def __init__(__dispatcher, /, __func__: T, **params: DispatchSpec) -> None: ...
    def resolve_parameters(self, impl: Callable) -> Iterator[dict]: ...
    __cache_activated__: bool
    def add_implementation(self, impl: Callable, key: dict | tuple, override: bool = False) -> None: ...
    def implement(self, impl: Callable) -> Callable: ...
    def bound_arguments(__dispatcher, /, *args, **kwargs) -> dict[str, Any]: ...
    def resolve_arguments(__dispatcher, /, *args, **kwargs): ...
    def get_implementation(self, param_key: dict): ...
    def specialize(__dispatcher: Dispatcher[T], /, *args, **kwargs) -> Callable[..., T]: ...
    def __call__(__dispatcher, /, *args, **kwargs): ...
    def __get__(self, obj, cls: Incomplete | None = None) -> T: ...
    @property
    def __isabstractmethod__(self): ...

def dispatch_on(**params: DispatchSpec) -> Callable[[T], T]: ...
def dispatch(func: T) -> T: ...
def is_dispatched(func: Callable) -> TypeGuard['SupportsDispatch']: ...
@overload
def implement_for(cls) -> Callable[[T], T]: ...
@overload
def implement_for(cls, name: str | None = None) -> Callable[[T], T]: ...
@overload
def implement_for(func: T) -> Callable[[T], T]: ...
def implement(impl: T) -> T: ...

class SupportsDispatch(Protocol):
    @property
    def dispatcher(self) -> Dispatcher: ...
    @property
    def __isabstractmethod__(self) -> bool: ...
    def __call__(self, *args, **kwargs) -> Any: ...
    def implement(self, impl: Callable) -> Callable: ...
    def specialize(self, *args, **kwargs) -> Callable[..., Callable]: ...
