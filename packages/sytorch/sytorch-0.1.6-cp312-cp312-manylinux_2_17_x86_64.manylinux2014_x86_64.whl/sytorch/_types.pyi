import numpy as np
import torch
from typing import Any, Iterator, Literal, Tuple, TypeVar, Union, overload
from builtins import bool as _bool

__all__ = ['stype', 'vtype', 'StorageFormat', 'EncodingScheme']

class __stypeMeta(type):
    __supports__: Tuple[SOLVER_FEATURE]
    def __new__(cls, name, bases, dct): ...
    def supports(cls, feature: SOLVER_FEATURE) -> _bool: ...
    def __lt__(cls, other) -> bool: ...
    def __le__(cls, other) -> bool: ...
T = TypeVar('T', bound='stype')

class stype(metaclass=__stypeMeta): ...

class stype(metaclass=__stypeMeta):
    T = TypeVar('T', bound='stype')
    @classmethod
    def register_solver(cls, *features: SOLVER_FEATURE) -> type[T]: ...
    class none(stype): ...
    class sympy(stype): ...
    class lp(stype): ...
    class jacobian(lp): ...
    class gurobi(stype): ...
    class highs(stype): ...
    class ortools(stype): ...
    class smt(stype): ...
    class z3(stype): ...
    class dreal(stype): ...
    @overload
    def __new__(cls, stype: Literal['sympy']) -> type[sympy]: ...
    @overload
    def __new__(cls, stype: Literal['lp']) -> type[lp]: ...
    @overload
    def __new__(cls, stype: Literal['gurobi']) -> type[gurobi]: ...
    @overload
    def __new__(cls, stype: Literal['highs']) -> type[highs]: ...
    @overload
    def __new__(cls, stype: type[T]) -> type[T]: ...
    @staticmethod
    def validate(x: Any) -> _bool: ...
    @classmethod
    def fallback(cls) -> Iterator[type['stype']]: ...

class __vtypeMeta(type):
    def __lt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    @property
    def dtype(self) -> torch.dtype: ...
    @property
    def numpy_dtype(self) -> np.dtype: ...

class vtype(metaclass=__vtypeMeta): ...

class vtype(metaclass=__vtypeMeta):
    T = TypeVar('T', bound='vtype')
    class value(vtype): ...
    class var(value): ...
    class real(var): ...
    class int(var): ...
    class bool(var): ...
    class constant(value): ...
    class real_const(constant): ...
    class int_const(constant): ...
    class bool_const(constant): ...
    class constraint(vtype): ...
    class lp_constr(constraint): ...
    @overload
    def __new__(cls, vtype: Literal['var']) -> type[var]: ...
    @overload
    def __new__(cls, vtype: Literal['real']) -> type[real]: ...
    @overload
    def __new__(cls, vtype: Literal['int']) -> type[int]: ...
    @overload
    def __new__(cls, vtype: Literal['bool']) -> type[bool]: ...
    @overload
    def __new__(cls, vtype: Literal['const']) -> type[constant]: ...
    @overload
    def __new__(cls, vtype: Literal['real_const']) -> type[real_const]: ...
    @overload
    def __new__(cls, vtype: Literal['int_const']) -> type[int_const]: ...
    @overload
    def __new__(cls, vtype: Literal['bool_const']) -> type[bool_const]: ...
    @overload
    def __new__(cls, vtype: Literal['constr']) -> type[constraint]: ...
    @overload
    def __new__(cls, vtype: Literal['lp_constr']) -> type[lp_constr]: ...
    @overload
    def __new__(cls, vtype: type[T]) -> type[T]: ...
    @staticmethod
    def validate(x: Any) -> _bool: ...
    @classmethod
    def fallback(cls) -> Iterator[type['vtype']]: ...

class __StorageFormatMeta(type): ...
class StorageFormat(metaclass=__StorageFormatMeta): ...

class StorageFormat(metaclass=__StorageFormatMeta):
    class Dense(StorageFormat): ...
    class Sparse(StorageFormat): ...
    def __new__(cls, format: Union[type['StorageFormat'], str]) -> type['StorageFormat']: ...
    @staticmethod
    def validate(x: Any) -> _bool: ...

class __EncodingSchemeMeta(type): ...
class EncodingScheme(metaclass=__EncodingSchemeMeta): ...

class EncodingScheme(metaclass=__EncodingSchemeMeta):
    class Delta(EncodingScheme): ...
    class AsIs(EncodingScheme): ...
    def __new__(cls, scheme: Union[type['EncodingScheme'], str]) -> type['EncodingScheme']: ...
    @staticmethod
    def validate(x: Any) -> _bool: ...

class __domainMeta(type): ...
class domain(metaclass=__domainMeta): ...

class domain(metaclass=__domainMeta):
    class point(domain): ...
    class APRNN(point): ...
    class hbox(domain): ...
    class PREPARED(hbox): ...
    def __new__(cls, value: Union[type['domain'], str]) -> type['domain']: ...
    @staticmethod
    def validate(x: Any) -> _bool: ...
