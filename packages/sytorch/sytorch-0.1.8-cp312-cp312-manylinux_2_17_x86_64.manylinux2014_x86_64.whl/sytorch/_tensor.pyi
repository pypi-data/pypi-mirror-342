import gurobipy as gp
import highspy as hp
import numpy as np
import sytorch as st
import torch
from ._stype import FEATURE as FEATURE
from ._typing import Any as Any, Dict as Dict, Generic as Generic, List as List, Literal as Literal, Optional as Optional, Self as Self, Sequence as Sequence, SupportsShape as SupportsShape, TYPE_CHECKING as TYPE_CHECKING, Tuple as Tuple, TypeAlias as TypeAlias, TypeGuard as TypeGuard, TypeIs as TypeIs, TypeVar as TypeVar, TypeVarTuple as TypeVarTuple, Union as Union, get_args as get_args, get_origin as get_origin, overload as overload
from .utils import ThreadSafeCounter as ThreadSafeCounter, dispatch_on as dispatch_on, to_numpy as to_numpy
from _typeshed import Incomplete
from collections import defaultdict
from sytorch._types import StorageFormat as StorageFormat
from sytorch.utils.array import to_tensor as to_tensor
from torch import SymInt as SymInt
from torch.types import _size
from types import EllipsisType, GenericAlias as GenericAlias, NoneType as NoneType
from typing import Callable

VALUE: TypeAlias
REAL: TypeAlias
CONSTANT: TypeAlias
CONSTR: TypeAlias
GUROBI: TypeAlias
HIGHS: TypeAlias
NoSolver: TypeAlias
ST = TypeVar('ST', bound=st.stype)
ST2 = TypeVar('ST2', bound=st.stype)
VT = TypeVar('VT', bound=st.vtype)
VT2 = TypeVar('VT2', bound=st.vtype)
Dense: Incomplete
Sparse: Incomplete
FT = TypeVar('FT', bound=StorageFormat, default=Dense)
FT2 = TypeVar('FT2', bound=StorageFormat, default=Dense)
FT3 = TypeVar('FT3', bound=StorageFormat, default=Dense)
EncodingScheme: Incomplete
Delta: Incomplete
AsIs: Incomplete
ET = TypeVar('ET', bound=EncodingScheme, default=AsIs)
ET2 = TypeVar('ET2', bound=EncodingScheme, default=AsIs)
ET3 = TypeVar('ET3', bound=EncodingScheme, default=AsIs)
DT = TypeVar('DT', bound=st.domain)
PointDT = TypeVar('PointDT', bound=st.domain.point, default=st.domain.APRNN)
BoxDT = TypeVar('BoxDT', bound=st.domain.hbox)
ConstantTensor: Incomplete
BooleanTensor: Incomplete
AnyConstantArrayLike: TypeAlias
AnyConstant: TypeAlias
AnyIndicesArrayLike: Incomplete
AnyIndices = AnyIndicesArrayLike | int

class _solver_descriptor:
    @overload
    def __get__(self, instance: Solver[GUROBI], owner: type | None = None, /) -> gp.Model: ...
    @overload
    def __get__(self, instance: Solver[HIGHS], owner: type | None = None, /) -> hp.Highs: ...

class Solver(Generic[ST]):
    __zero__: SymbolicTensor[ST, REAL]
    __cached_constant__: Dict[float, Any]
    @property
    def __type_args__(self) -> Tuple[type[ST]]: ...
    @overload
    def __init__(self, stype: Literal['gurobi'] = 'gurobi', *args, **kwargs) -> None: ...
    @overload
    def __init__(self, stype: type[GUROBI], *args, **kwargs) -> None: ...
    def __solver_init__(self, *args, **kwargs) -> None: ...
    @property
    def stype(self) -> type[ST]: ...
    @property
    def counters(self) -> defaultdict[Any, st.utils.ThreadSafeCounter]: ...
    def supports(self, feature: FEATURE) -> bool: ...
    @property
    def solver(self) -> Any: ...
    solver: _solver_descriptor
    def verbose_(self, mode: bool = True): ...
    def push(self): ...
    def pop(self): ...
    def new_scope(self): ...
    @overload
    def to(self, solver: Literal['gurobi']) -> Solver[GUROBI]: ...
    @overload
    def to(self, solver: Union['Solver[ST2]', type[ST2]]) -> Solver[ST2]: ...
    def __add_one_constraint__(self, constr: Any) -> None: ...
    def add_constraints(self, *constraints: SymbolicTensor[ST, CONSTR]) -> None: ...
    add_constr = add_constraints
    def solve(self, *constraints: SymbolicTensor[ST, CONSTR], minimize: Optional['SymbolicTensor[ST, REAL]'] = None, maximize: Optional['SymbolicTensor[ST, REAL]'] = None, **kwargs) -> bool: ...
    def __evaluate_scalar__(self, v: Any) -> Any: ...
    def evaluate(self, data: SymbolicTensor[ST, VT, FT, ET] | np.ndarray, *, device: Optional[torch.device] = None, dtype: Optional[torch.dtype] = None) -> torch.Tensor: ...
    def vars(self, *shape: int, vtype: type[VT], mask: Optional[torch.Tensor] = None, lb: Optional[AnyConstant] = None, ub: Optional[AnyConstant] = None) -> SymbolicTensor[ST, VT]: ...
    def __add_real_var__(self, name: Optional[int | str] = None, lb: Optional[float] = None, ub: Optional[float] = None) -> Any: ...
    def __reals__(self, *shape: int, lb: Optional[AnyConstant] = None, ub: Optional[AnyConstant] = None, device: Optional[torch.device] = None, dtype: Optional[torch.dtype] = None) -> SymbolicTensor[ST, REAL]: ...
    @overload
    def reals(self, *shape: int, lb: Optional[AnyConstant] = None, ub: Optional[AnyConstant] = None, device: Optional[torch.device] = None, dtype: Optional[torch.dtype] = None) -> SymbolicTensor[ST, REAL, Dense, AsIs]: ...
    @overload
    def reals(self, *shape: int, mask: torch.Tensor, lb: Optional[AnyConstant] = None, ub: Optional[AnyConstant] = None, device: Optional[torch.device] = None, dtype: Optional[torch.dtype] = None) -> SymbolicTensor[ST, REAL, Sparse, AsIs]: ...
    def real(self, lb: Optional[AnyConstant] = None, ub: Optional[AnyConstant] = None) -> SymbolicTensor[ST, REAL]: ...

class SymbolicTensor(Generic[ST, VT, FT, ET]):
    @property
    def __type_args__(self) -> Tuple[type[ST], type[VT], type[FT], type[ET]]: ...
    @property
    def __type_repr__(self) -> str: ...
    @overload
    def __init__(self, data: SymbolicTensor[ST, VT, Dense, AsIs], /, *, base: Optional[ConstantTensor] = None, mask: None = None, encoding: type[ET] = ...) -> None: ...
    @overload
    def __init__(self, data: np.ndarray, /, *, solver: Solver[ST], vtype: type[VT], base: Optional[ConstantTensor] = None, mask: None = None, encoding: type[ET] = ...) -> None: ...
    @overload
    def __init__(self, data: SymbolicTensor[ST, VT, Dense, AsIs], /, *, base: Optional[ConstantTensor] = None, mask: BooleanTensor, encoding: type[ET] = ...) -> None: ...
    @overload
    def __init__(self, data: np.ndarray, /, *, solver: Solver[ST], vtype: type[VT], base: Optional[ConstantTensor] = None, mask: BooleanTensor, encoding: type[ET] = ...) -> None: ...
    def __init_dense_direct__(self, *, data: np.ndarray, device: torch.device, dtype: torch.dtype) -> None: ...
    def __init_dense_delta__(self, *, data: np.ndarray, base: ConstantTensor, device: torch.device, dtype: torch.dtype) -> None: ...
    def __init_sparse_direct__(self, *, data: np.ndarray, base: ConstantTensor, mask: BooleanTensor, device: torch.device, dtype: torch.dtype) -> None: ...
    def __init_sparse_delta__(self, *, data: np.ndarray, base: ConstantTensor, mask: BooleanTensor, device: torch.device, dtype: torch.dtype) -> None: ...
    def shallow_copy(self) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def clone(self) -> SymbolicTensor[ST, VT, FT, ET]: ...
    deepcopy = clone
    @property
    def device(self) -> torch.device: ...
    @property
    def dtype(self) -> torch.dtype: ...
    @property
    def solver(self) -> Solver[ST]: ...
    @property
    def stype(self) -> type[ST]: ...
    @property
    def vtype(self) -> type[VT]: ...
    @property
    def storage_format(self) -> type[FT]: ...
    @property
    def encoding_scheme(self) -> type[ET]: ...
    @overload
    def is_(self, device: Optional[torch.device] = None, dtype: Optional[torch.dtype] = None, shape: Optional[torch.Size] = None, stype: Optional[type[st.stype]] = None, vtype: Optional[type[st.vtype]] = None, storage_format: Optional[type[st.StorageFormat]] = None, encoding_scheme: Optional[type[st.EncodingScheme]] = None) -> bool: ...
    @overload
    def cast_(self, storage_format: type[FT2], encoding_scheme: type[ET2]) -> SymbolicTensor[ST, VT, FT2, ET2]: ...
    @overload
    def cast_(self, storage_format: type[FT2]) -> SymbolicTensor[ST, VT, FT2, ET]: ...
    @overload
    def cast_(self, encoding_scheme: type[ET2]) -> SymbolicTensor[ST, VT, FT, ET2]: ...
    def is_dense(self) -> bool: ...
    def is_sparse(self) -> bool: ...
    def is_direct(self) -> bool: ...
    def is_delta(self) -> bool: ...
    def as_point(self, domain: type[PointDT] = ...) -> Point[Self, PointDT]: ...
    def as_box(self, domain: type[BoxDT] = ...) -> Box[Self, BoxDT]: ...
    @property
    def data(self) -> np.ndarray: ...
    @property
    def base(self) -> ConstantTensor: ...
    @property
    def mask(self) -> BooleanTensor: ...
    def mask_at_dim(self, *dims: int) -> BooleanTensor: ...
    def get_lb(self) -> torch.Tensor: ...
    def get_ub(self) -> torch.Tensor: ...
    def get_bounds(self) -> Tuple[torch.Tensor, torch.Tensor]: ...
    def to(self, *args, **kwargs) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def numpy(self) -> np.ndarray: ...
    def to_var(self) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def to_var_(self) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def to_dense_asis(self) -> SymbolicTensor[ST, VT, Dense, AsIs]: ...
    def to_dense_delta(self) -> SymbolicTensor[ST, VT, Dense, Delta]: ...
    def to_sparse_asis(self) -> SymbolicTensor[ST, VT, Sparse, AsIs]: ...
    def to_sparse_delta(self) -> SymbolicTensor[ST, VT, Sparse, Delta]: ...
    def to_dense(self) -> SymbolicTensor[ST, VT, Dense, ET]: ...
    def to_sparse(self) -> SymbolicTensor[ST, VT, Sparse, ET]: ...
    def to_asis(self) -> SymbolicTensor[ST, VT, FT, AsIs]: ...
    def to_delta(self) -> SymbolicTensor[ST, VT, FT, Delta]: ...
    def sparse_delta(self) -> SymbolicTensor[ST, VT, Sparse, AsIs]: ...
    def masked_block(self) -> SymbolicTensor[ST, VT, Sparse, ET]: ...
    def dense_delta(self) -> SymbolicTensor[ST, VT, Dense, AsIs]: ...
    def dense_delta_1d(self) -> SymbolicTensor[ST, VT, Dense, AsIs]: ...
    def masked_sparse_delta_block(self) -> SymbolicTensor[ST, VT, Sparse, AsIs]: ...
    def evaluate(self) -> torch.Tensor: ...
    def assert_(self) -> None: ...
    def __getitem__(self, index) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def __setitem__(self, indices, val) -> None: ...
    def item(self): ...
    @property
    def ndim(self) -> int: ...
    @property
    def shape(self) -> torch.Size: ...
    def size(self, dim: Optional[int] = None): ...
    def numel(self) -> int: ...
    @property
    def T(self) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def reshape(self, shape: Union[int, torch.Size, Sequence[Union[int, SymInt]]]) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def reshape(self, *shape: Union[int, torch.Size, Sequence[Union[int, SymInt]]]) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def reshape_as(self, other: SupportsShape) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def view(self, shape: Union[int, torch.Size, Sequence[Union[int, SymInt]]]) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def view(self, *shape: Union[int, torch.Size, Sequence[Union[int, SymInt]]]) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def view_as(self, other: SupportsShape) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def flatten(self, start_dim: int = 0, end_dim: int = -1) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def squeeze(self) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def squeeze(self, dim: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def squeeze(self, dim: _size) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def squeeze(self, *dim: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def squeeze(self, dim: Union[str, EllipsisType, None]) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def squeeze_(self) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def squeeze_(self, dim: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def squeeze_(self, dim: _size) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def squeeze_(self, *dim: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def squeeze_(self, dim: Union[str, EllipsisType, None]) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def unsqueeze(self, dim: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def unsqueeze_(self, dim: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def expand(self, size: Sequence[Union[int, SymInt]], *, implicit: bool = False) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def expand(self, *size: Union[int, SymInt], implicit: bool = False) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def expand_as(self, other: SupportsShape) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def permute(self, dims: _size) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def permute(self, *dims: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def transpose(self, dim0: int, dim1: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    @overload
    def transpose(self, dim0: Union[str, EllipsisType, None], dim1: Union[str, EllipsisType, None]) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def transpose_(self, dim0: int, dim1: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def chunk(self, chunks: int, dim: int = 0) -> Tuple['SymbolicTensor[ST, VT, FT, ET]', ...]: ...
    @overload
    def split(self, split_size: int, dim: int = 0) -> Sequence['SymbolicTensor[ST, VT, FT, ET]']: ...
    @overload
    def split(self, split_size: Tuple[int, ...], dim: int = 0) -> Sequence['SymbolicTensor[ST, VT, FT, ET]']: ...
    def take_along_dim(self, indices: torch.Tensor, dim: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def exclude_along_dim(self, indices: torch.Tensor, dim: int) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def __len__(self) -> int: ...
    def __add__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __radd__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __iadd__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __sub__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __rsub__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __isub__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __mul__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __rmul__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __imul__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __truediv__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __rtruediv__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __itruediv__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __matmul__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstantArrayLike) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __rmatmul__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstantArrayLike) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __imatmul__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstantArrayLike) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __pow__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __rpow__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __ipow__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __mod__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __rmod__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __imod__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __and__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __or__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __xor__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __eq__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, CONSTR, FT3, ET3]: ...
    def __ne__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, CONSTR, FT3, ET3]: ...
    def __lt__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, CONSTR, FT3, ET3]: ...
    def __le__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, CONSTR, FT3, ET3]: ...
    def __gt__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, CONSTR, FT3, ET3]: ...
    def __ge__(self, other: SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant) -> SymbolicTensor[ST, CONSTR, FT3, ET3]: ...
    def __pos__(self) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __neg__(self) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __invert__(self) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def __abs__(self) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    @overload
    def sum(self, *, dtype: Optional[torch.dtype] = None) -> SymbolicTensor[ST, VALUE, FT, ET]: ...
    @overload
    def sum(self, dim: Optional[Union[int, torch.Size]], keepdim: bool = False, *, dtype: Optional[torch.dtype] = None) -> SymbolicTensor[ST, VALUE, FT, ET]: ...
    @overload
    def sum(self, dim: Sequence[Union[str, Ellipsis, None]], keepdim: bool = False, *, dtype: Optional[torch.dtype] = None) -> SymbolicTensor[ST, VALUE, FT, ET]: ...
    def contract(self, other: AnyConstant, *, bias: Optional[SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant] = None) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
    def abs_ub(self) -> SymbolicTensor[ST, VT, Dense, AsIs]: ...
    def max_ub(self) -> SymbolicTensor[ST, VT, Dense, AsIs]: ...
    def norm_ub(self, order: Literal['l1', 'l1n', 'linf', 'l1n+linf']) -> SymbolicTensor[ST, VT, Dense, AsIs]: ...
    def tighten_(self, lb: Optional[AnyConstant] = None, ub: Optional[AnyConstant] = None, override: bool = False) -> SymbolicTensor[ST, VT, FT, ET]: ...
    def __argmax_eq__(self, target: AnyIndices, dim: int = -1, **kwargs) -> SymbolicTensor[ST, CONSTR, Dense, AsIs]: ...
    def argmax(self, dim: int, **kwargs) -> EqEncoder[SymbolicTensor[ST, VT, FT, ET], AnyIndices, SymbolicTensor[ST, CONSTR, Dense, AsIs]]: ...
selfT = TypeVar('selfT')
otherT = TypeVar('otherT')
retT = TypeVar('retT')

class EqEncoder(Generic[selfT, otherT, retT]):
    method: Callable[[otherT], retT]
    kwargs: Dict[str, Any]
    def __init__(self, method: Callable[[selfT, otherT], retT], **kwargs) -> None: ...
    def __eq__(self, other: otherT) -> retT: ...

@overload
def contract(a: SymbolicTensor[ST, VT, FT, ET], b: AnyConstant, *, bias: Optional[SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant] = None) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
@overload
def contract(a: AnyConstant, b: SymbolicTensor[ST, VT, FT, ET], *, bias: Optional[SymbolicTensor[ST, VT, FT2, ET2] | AnyConstant] = None) -> SymbolicTensor[ST, VT, FT3, ET3]: ...
@overload
def cat(tensors: Union[Tuple[SymbolicTensor[ST, VT, FT, ET], ...], List[SymbolicTensor[ST, VT, FT, ET]]], dim: int = 0, *, out: Optional[SymbolicTensor[ST, VT, FT, ET]] = None) -> SymbolicTensor[ST, VT, FT, ET]: ...
def stack(tensors: Union[Tuple[SymbolicTensor[ST, VT], ...], List[SymbolicTensor[ST, VT]]], dim: int = 0, *, out: Optional[SymbolicTensor[ST, VT]] = None) -> SymbolicTensor[ST, VT]: ...
def _(tensors: Union[Tuple[SymbolicTensor[ST, VT, FT, ET], ...], List[SymbolicTensor[ST, VT, FT, ET]]], dim: int, *, numpy_fn: Callable, torch_fn: Callable, solver: Solver[ST], vtype: type[st.vtype], format: type[Dense], encoding: type[AsIs]) -> SymbolicTensor[ST, VT, FT, ET]: ...
def symbolic_tensor(data: np.ndarray, /, *, solver: Solver[ST], vtype: type[VT] = ..., **kwargs) -> SymbolicTensor[ST, VT, Dense, AsIs]: ...
def dense_tensor(data: np.ndarray, /, *, solver: Solver[ST], vtype: type[VT] = ..., **kwargs) -> SymbolicTensor[ST, VT, Dense, AsIs]: ...
def dense_real_tensor(data: np.ndarray, /, *, solver: Solver[ST], **kwargs) -> SymbolicTensor[ST, REAL, Dense, AsIs]: ...
@overload
def dense_delta_real_tensor(data: np.ndarray, *, solver: Solver[ST], base: ConstantTensor) -> SymbolicTensor[ST, REAL, Dense, Delta]: ...
@overload
def dense_delta_real_tensor(data: SymbolicTensor[ST, REAL, Dense, AsIs], *, base: ConstantTensor) -> SymbolicTensor[ST, REAL, Dense, Delta]: ...
def dense_constr_tensor(data: np.ndarray, /, *, solver: Solver[ST]) -> SymbolicTensor[ST, CONSTR, Dense, AsIs]: ...
def sparse_tensor(data: np.ndarray, /, *, mask: BooleanTensor, base: Optional[ConstantTensor] = None, solver: Solver[ST], vtype: type[VT] = ..., **kwargs) -> SymbolicTensor[ST, VT, Sparse, AsIs]: ...
@overload
def sparse_delta_tensor(data: np.ndarray, /, *, base: ConstantTensor, mask: BooleanTensor, solver: Solver[ST], vtype: type[VT] = ...) -> SymbolicTensor[ST, VT, Sparse, Delta]: ...
@overload
def sparse_delta_tensor(data: SymbolicTensor[ST, VT, Dense, AsIs], /, *, base: ConstantTensor, mask: BooleanTensor) -> SymbolicTensor[ST, VT, Sparse, Delta]: ...
@overload
def sparse_delta_real_tensor(data: np.ndarray, /, *, base: ConstantTensor, mask: BooleanTensor, solver: Solver[ST]) -> SymbolicTensor[ST, REAL, Sparse, Delta]: ...
@overload
def sparse_delta_real_tensor(data: SymbolicTensor[ST, REAL, Dense, AsIs], /, *, base: ConstantTensor, mask: BooleanTensor) -> SymbolicTensor[ST, REAL, Sparse, Delta]: ...
@overload
def sparse_delta_real_tensor(data: SymbolicTensor[ST, REAL, Sparse, AsIs], /, *, base: ConstantTensor) -> SymbolicTensor[ST, REAL, Sparse, Delta]: ...

class Domain(Generic[_T, DT]):
    data: _T
    domain: type[DT]
    @property
    def __type_args__(self): ...
    @property
    def __type_repr__(self) -> str: ...
    def __getitem__(self, index) -> Self: ...
    def __setitem__(self, index, value) -> None: ...
    def deepcopy(self) -> Self: ...
    clone = deepcopy
    def apply_(self, fn: Callable[[_T], _T], *args, **kwargs) -> Self: ...
    def apply(self, fn: Callable[[_T], _T], *args, **kwargs) -> Self: ...
    def assert_(self): ...

class Point(Domain[_T, PointDT]):
    data: _T
    domain: type[PointDT]
    @property
    def ref(self) -> ConstantTensor: ...
    def __init__(self, data: _T, domain: type[PointDT] = ...) -> None: ...
    @overload
    def __add__(self, other: Point[SymbolicTensor[ST, VT, FT2, ET2], PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __add__(self, other: Point[AnyConstant, PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __add__(self, other: SymbolicTensor[ST, VT, FT2, ET2]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __add__(self, other: AnyConstant) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __ge__(self, other: Point[SymbolicTensor[ST, VT, FT2, ET2], PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __ge__(self, other: Point[AnyConstant, PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __ge__(self, other: SymbolicTensor[ST, VT, FT2, ET2]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __ge__(self, other: AnyConstant) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __le__(self, other: Point[SymbolicTensor[ST, VT, FT2, ET2], PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __le__(self, other: Point[AnyConstant, PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __le__(self, other: SymbolicTensor[ST, VT, FT2, ET2]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __le__(self, other: AnyConstant) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __gt__(self, other: Point[SymbolicTensor[ST, VT, FT2, ET2], PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __gt__(self, other: Point[AnyConstant, PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __gt__(self, other: SymbolicTensor[ST, VT, FT2, ET2]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __gt__(self, other: AnyConstant) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __lt__(self, other: Point[SymbolicTensor[ST, VT, FT2, ET2], PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __lt__(self, other: Point[AnyConstant, PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __lt__(self, other: SymbolicTensor[ST, VT, FT2, ET2]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __lt__(self, other: AnyConstant) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __eq__(self, other: Point[SymbolicTensor[ST, VT, FT2, ET2], PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __eq__(self, other: Point[AnyConstant, PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __eq__(self, other: SymbolicTensor[ST, VT, FT2, ET2]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __eq__(self, other: AnyConstant) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __ne__(self, other: Point[SymbolicTensor[ST, VT, FT2, ET2], PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __ne__(self, other: Point[AnyConstant, PointDT]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __ne__(self, other: SymbolicTensor[ST, VT, FT2, ET2]) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...
    @overload
    def __ne__(self, other: AnyConstant) -> Point[SymbolicTensor[ST, CONSTR], PointDT]: ...

SymbolicPoint: Incomplete
