import numpy as np
import torch
from _typeshed import Incomplete
from collections.abc import Generator
from sytorch import SymbolicTensor as SymbolicTensor
from sytorch._typing import ArrayLike as ArrayLike
from typing import Sequence, overload

def to_numpy(x: ArrayLike) -> np.ndarray: ...
def to_tensor(x, *, shape: tuple[int, ...] | None = None, device: torch.device | None = None, dtype: torch.dtype | None = None) -> torch.Tensor: ...
def iter_nested(arr) -> Generator[Incomplete, Incomplete]: ...
def to_shape(shape) -> tuple[int]: ...
def get_device(x) -> torch.device: ...
def get_dtype(x) -> torch.dtype: ...
def batched(model: torch.nn.Module, inputs: torch.Tensor, batch_size: int, desc: str = 'batched inference', device: Incomplete | None = None): ...
def compute_targets(buggy_outputs, labels, topk: Incomplete | None = None, device: Incomplete | None = None): ...
def make_mask(shape: Sequence[int], slice_at_dim: dict[int, slice | Sequence[int] | torch.Tensor]) -> torch.Tensor: ...

class MaskSpec:
    slice_at_dim: Incomplete
    def __init__(self, slices_at_dim: dict[int, slice | Sequence[int] | torch.Tensor]) -> None: ...
    def __call__(self, shape: tuple[int, ...]) -> torch.Tensor: ...

def mask_at_dim(mask, *dims: int) -> torch.Tensor: ...
def masked_block(mask: torch.Tensor) -> tuple[torch.Tensor, tuple[int, ...]]: ...
def make_readonly(array, readonly: bool = False): ...
def parse_range(value) -> list[int]: ...

__zero__: Incomplete
__one__: Incomplete
__minus_one__: Incomplete

def zeros_view(*shape): ...
def ones_view(*shape): ...
def minus_ones_view(*shape): ...
def value_view(value, shape): ...
def eye_view(M, value: float = 1.0): ...
@overload
def expand_targets(targets: torch.Tensor | np.ndarray, output: torch.Tensor, dim: int = -1) -> torch.Tensor: ...
@overload
def expand_targets(targets: torch.Tensor | np.ndarray, output: SymbolicTensor, dim: int = -1) -> torch.Tensor: ...
@overload
def expand_targets(targets: torch.Tensor | np.ndarray, output: np.ndarray, dim: int = -1) -> np.ndarray: ...
@overload
def gather_targets(outputs: torch.Tensor, targets: torch.Tensor, dim: int = -1) -> torch.Tensor: ...
@overload
def gather_targets(outputs: SymbolicTensor, targets: torch.Tensor, dim: int = -1) -> SymbolicTensor: ...
