Metadata-Version: 2.4
Name: Bynd
Version: 0.1
Summary: Bynd is a simple way of achieving static typing in Python.
Author-email: "Rayshawn Levy (sneekyfoxx)" <sneekyfoxx09@gmail.com>
Maintainer-email: "Rayshawn Levy (sneekyfoxx)" <sneekyfoxx09@gmail.com>
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Natural Language :: English
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Topic :: Other/Nonlisted Topic
Classifier: Typing :: Typed
Requires-Python: >=3.10
Description-Content-Type: text/markdown

> A module which allows binding values to one or more types.
> The most common use case would be to use bynd as if were an
> alias. When assigning a bynd object to a variable, the user
> will get runtime type checking, a bynd object in return, and
> access to the supplied value as well as the supplied types,
> where the value can be used the same way a variable would be
> used. The only inconvienence would be having to use the dot
> operator when accessing the value from the bynd object and
> maybe having to declare, define and instantiate a bynd object
> each time.

### Examples:
```python
from bynd import bynd

# Instantiate a bynd object
my_variable = bynd("some string")[str]  # raises a 'byndError' if ("some string") is not a str

# In the above example, we create a variable named 'my_variable'.
# Then, we instantiate a 'bynd' object and pass it a string value ("some string").
# Finally, we bind the string value ("some string") to the type [str].

# To access the string value ("some string"), we can use the dot '.' operator.
print(my_variable.value)

# The type(s) can also be accessed the same way.
print(my_variable.types)

# bynd also does recursive type checks for collection types only.
# First, we create a variable named 'my_list' and instantiate
# another 'bynd' object passing it the of a list that contains 
# another list. Secondly, we specify that the value passed should
# be of type 'list'.
my_list = bynd([1,2,3,[4,5,6]])[list]

# Thirdly, for bynd to perform recursive type checking we have to
# use a bynd method named 'inner_types' which allows us to specify
# which types the original and inner lists should contain. To specify
# such types, we need to use the 'others' keyword argument and pass it
# a list of expected types.
my_list.inner_types(others=[int])  # raises an error when either of the lists doesn't follow the type rules

# Finally, if there aren't any errors, we can access and print the lists.
print(my_list.value)

# NOTE: recursive type checking anly occurs when the 'inner_types' method is used and if it encounters a
#       collection type within another collection type. This happens automatically within the 'inner_types'
#       method itself.
```
