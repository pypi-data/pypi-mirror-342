# {{ config.project_name }}

{{ config.description }}

This project is an MCP (Model Context Protocol) server generated by `mcp-forge`. It provides a starting point for building your own server with custom tools and resources.

## Project Structure

```
./
├── {{ config.package_name }}/           # Python package for your server code
│   ├── __init__.py              # Package initialization
│   ├── server.py                # Unified server entry point with mode selection
│   ├── server_stdio.py          # Implementation for stdio transport
│   ├── server_sse.py            # Implementation for SSE transport (HTTP)
│   ├── interfaces/              # Base classes/interfaces for tools and resources
│   │   ├── __init__.py
│   │   ├── resource.py
│   │   └── tool.py
│   ├── resources/               # Implementation of resources
│   │   ├── __init__.py
│   │   ├── hello_world.py       # Example static resource
│   │   └── user_profile.py      # Example dynamic resource with URI parameters
│   ├── services/                # Services for managing tools and resources
│   │   ├── __init__.py
│   │   ├── resource_service.py  # Handles resource registration and routing
│   │   └── tool_service.py      # Handles tool registration and execution
│   └── tools/                   # Implementation of tools
│       ├── __init__.py
│       └── hello_world.py       # Example tool with input/output schemas
├── pyproject.toml               # Project metadata and dependencies (using Hatch)
└── README.md                    # This file
```

## Setup

This project uses `uv` for dependency management. Ensure you have `uv` installed (`pip install uv`).

1.  **Navigate** into the project directory:
    ```bash
    cd {{ config.project_name }}
    ```
2.  **Create a virtual environment** and install dependencies:
    ```bash
    uv venv
    uv pip install -e .
    ```

## Running the Server

The server can run in two modes: `stdio` (standard input/output) or `sse` (HTTP Server-Sent Events). You must specify the desired mode using the `--mode` parameter.

### Using the Command Line Script

After installation, you can use the `{{ config.project_name }}` command directly:

```bash
# Run in stdio mode
{{ config.project_name }} --mode=stdio

# Run in SSE mode (defaults to http://0.0.0.0:6969)
{{ config.project_name }} --mode=sse

# Run in SSE mode with custom host/port
{{ config.project_name }} --mode=sse --host 127.0.0.1 --port 8000

# Run in SSE mode with auto-reload for development
{{ config.project_name }} --mode=sse --reload
```

### Using Python Module

Alternatively, you can run the server as a Python module:

```bash
# Using the unified server script
uv run -m {{ config.package_name }}.server --mode=stdio
uv run -m {{ config.package_name }}.server --mode=sse

# Or call the specific implementations directly
uv run -m {{ config.package_name }}.server_stdio
uv run -m {{ config.package_name }}.server_sse
```

## Developing Your Server

### Development Mode with Auto-Reload

For faster development with the SSE mode, you can use the auto-reload feature which automatically restarts the server when code changes are detected:

```bash
{{ config.project_name }} --mode=sse --reload
```

This is particularly useful during active development as you won't need to manually restart the server after each code change.

### Adding New Tools

1.  **Create a new Python file** in the `{{ config.package_name }}/tools/` directory (e.g., `my_tool.py`).
2.  **Define your tool class** inheriting from `Tool` (from `{{ config.package_name }}.interfaces.tool`).
3.  **Define an input model** inheriting from `BaseToolInput` for your tool's parameters using Pydantic.
4.  **Implement the `execute` method** containing your tool's logic.
5.  **Import and add your tool class** to the `__all__` list in `{{ config.package_name }}/tools/__init__.py`.
6.  **Instantiate your tool** in the `get_available_tools` function within `{{ config.package_name }}/server_stdio.py` and `{{ config.package_name }}/server_sse.py`.

### Adding New Resources

1.  **Create a new Python file** in the `{{ config.package_name }}/resources/` directory (e.g., `my_resource.py`).
2.  **Define your resource class** inheriting from `Resource` (from `{{ config.package_name }}.interfaces.resource`).
3.  **Define the required class attributes**: `name`, `description`, `uri`, `mime_type`.
4.  **Implement the `read` method**. For dynamic URIs (e.g., `data://{item_id}`), parameters are passed as keyword arguments to `read` (e.g., `read(item_id=...)`).
5.  **Import and add your resource class** to the `__all__` list in `{{ config.package_name }}/resources/__init__.py`.
6.  **Instantiate your resource** in the `get_available_resources` function within `{{ config.package_name }}/server_stdio.py` and `{{ config.package_name }}/server_sse.py`.

### Service Layer

- `ToolService`: Manages the registration and execution of tools. It dynamically creates handler functions based on tool input schemas.
- `ResourceService`: Manages the registration and reading of resources. It handles routing for static and dynamic URIs.

## Learn More About MCP

Visit the official [Model Context Protocol Documentation](https://modelcontextprotocol.io/) for detailed information about the protocol, concepts, and advanced features.
