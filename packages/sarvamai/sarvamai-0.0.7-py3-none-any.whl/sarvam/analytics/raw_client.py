# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .. import core
from ..types.speech_to_text_translate_model import SpeechToTextTranslateModel
from ..core.request_options import RequestOptions
from ..core.http_response import HttpResponse
from ..types.call_analytics_response import CallAnalyticsResponse
from ..core.pydantic_utilities import parse_obj_as
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..types.error_message import ErrorMessage
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.internal_server_error import InternalServerError
from ..errors.service_unavailable_error import ServiceUnavailableError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..types.text_analytics_response import TextAnalyticsResponse
from ..core.client_wrapper import AsyncClientWrapper
from ..core.http_response import AsyncHttpResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawAnalyticsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def call(
        self,
        *,
        file: core.File,
        questions: str,
        hotwords: typing.Optional[str] = OMIT,
        model: typing.Optional[SpeechToTextTranslateModel] = OMIT,
        with_diarization: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CallAnalyticsResponse]:
        """
        Given an audio file of a call between two parties and a list of questions, this API analyzes the content and returns the transcript, along with responses to the questions. Each response is supported by reasoning and exact phrases extracted from the transcript.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        questions : str
            List of questions to be answered based on the call content. Each question should be a valid `JSON` object with the following structure: ```{id: string, text: string, description: string (optional), type: string, properties: object}```.
            The `type` field must be one of: `boolean`, `enum`, `short answer`, `long answer`, or `number`.
            For `enum` type questions, include an 'options' list in the properties.

        hotwords : typing.Optional[str]
            Optional comma-separated string of keywords specific to your domain. These keywords will be preserved as-is in the transcript.

        model : typing.Optional[SpeechToTextTranslateModel]
            Model to be used for converting speech to text in target language

        with_diarization : typing.Optional[bool]
            Include diarization in the output

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CallAnalyticsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "call-analytics",
            method="POST",
            data={
                "questions": questions,
                "hotwords": hotwords,
                "model": model,
                "with_diarization": with_diarization,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CallAnalyticsResponse,
                    parse_obj_as(
                        type_=CallAnalyticsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def text(
        self, *, text: str, questions: str, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[TextAnalyticsResponse]:
        """
        This endpoint performs comprehensive text analysis on provided content and answers specific questions about the text. Each response is supported by reasoning and the exact phrase extracted from the content.

        Parameters
        ----------
        text : str
            The text content to be analyzed. This should be a non-empty string containing the full text for analysis.

        questions : str
            List of questions to be answered based on the call content. Each question should be a valid JSON object with the following structure: ```{id: string, text: string, description: string (optional), type: string, properties: object}.```The `type` field must be one of: `boolean`, `enum`, `short answer`, `long answer`, or `number`. For `enum` type questions, include an 'options' list in the properties.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TextAnalyticsResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "text-analytics",
            method="POST",
            json={
                "text": text,
                "questions": questions,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TextAnalyticsResponse,
                    parse_obj_as(
                        type_=TextAnalyticsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncRawAnalyticsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def call(
        self,
        *,
        file: core.File,
        questions: str,
        hotwords: typing.Optional[str] = OMIT,
        model: typing.Optional[SpeechToTextTranslateModel] = OMIT,
        with_diarization: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CallAnalyticsResponse]:
        """
        Given an audio file of a call between two parties and a list of questions, this API analyzes the content and returns the transcript, along with responses to the questions. Each response is supported by reasoning and exact phrases extracted from the transcript.

        Parameters
        ----------
        file : core.File
            See core.File for more documentation

        questions : str
            List of questions to be answered based on the call content. Each question should be a valid `JSON` object with the following structure: ```{id: string, text: string, description: string (optional), type: string, properties: object}```.
            The `type` field must be one of: `boolean`, `enum`, `short answer`, `long answer`, or `number`.
            For `enum` type questions, include an 'options' list in the properties.

        hotwords : typing.Optional[str]
            Optional comma-separated string of keywords specific to your domain. These keywords will be preserved as-is in the transcript.

        model : typing.Optional[SpeechToTextTranslateModel]
            Model to be used for converting speech to text in target language

        with_diarization : typing.Optional[bool]
            Include diarization in the output

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CallAnalyticsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "call-analytics",
            method="POST",
            data={
                "questions": questions,
                "hotwords": hotwords,
                "model": model,
                "with_diarization": with_diarization,
            },
            files={
                "file": file,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CallAnalyticsResponse,
                    parse_obj_as(
                        type_=CallAnalyticsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def text(
        self, *, text: str, questions: str, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[TextAnalyticsResponse]:
        """
        This endpoint performs comprehensive text analysis on provided content and answers specific questions about the text. Each response is supported by reasoning and the exact phrase extracted from the content.

        Parameters
        ----------
        text : str
            The text content to be analyzed. This should be a non-empty string containing the full text for analysis.

        questions : str
            List of questions to be answered based on the call content. Each question should be a valid JSON object with the following structure: ```{id: string, text: string, description: string (optional), type: string, properties: object}.```The `type` field must be one of: `boolean`, `enum`, `short answer`, `long answer`, or `number`. For `enum` type questions, include an 'options' list in the properties.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TextAnalyticsResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "text-analytics",
            method="POST",
            json={
                "text": text,
                "questions": questions,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TextAnalyticsResponse,
                    parse_obj_as(
                        type_=TextAnalyticsResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    typing.cast(
                        ErrorMessage,
                        parse_obj_as(
                            type_=ErrorMessage,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
