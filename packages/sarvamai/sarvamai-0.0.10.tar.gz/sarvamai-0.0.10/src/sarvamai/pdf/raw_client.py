# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .. import core
from ..types.sarvam_mode import SarvamMode
from ..types.prompt_caching import PromptCaching
from ..core.request_options import RequestOptions
from ..core.http_response import HttpResponse
from ..types.parsed_page_response import ParsedPageResponse
from ..core.pydantic_utilities import parse_obj_as
from ..errors.bad_request_error import BadRequestError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..types.language import Language
from ..types.translated_page import TranslatedPage
from ..core.client_wrapper import AsyncClientWrapper
from ..core.http_response import AsyncHttpResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawPdfClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def parse(
        self,
        *,
        pdf: core.File,
        page_number: typing.Optional[str] = OMIT,
        sarvam_mode: typing.Optional[SarvamMode] = OMIT,
        prompt_caching: typing.Optional[PromptCaching] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ParsedPageResponse]:
        """
        Given a PDF, this API helps to get structured extraction of data in the document.The API returns a base64 encoded XML string containing the extracted data.

        Parameters
        ----------
        pdf : core.File
            See core.File for more documentation

        page_number : typing.Optional[str]
            The page number you want to extract data from. This is a one-based index (meaning, the first page is 1).

        sarvam_mode : typing.Optional[SarvamMode]
            The mode of parsing to use:

            - small: Use this mode for economical and fast parsing
            - large: Use this mode for highest precision parsing

        prompt_caching : typing.Optional[PromptCaching]
            Whether to cache the prompt for the parse request. This is useful when running multiple requests to the parsing endpoint.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ParsedPageResponse]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "parse/parsepdf",
            method="POST",
            data={
                "page_number": page_number,
                "sarvam_mode": sarvam_mode,
                "prompt_caching": prompt_caching,
            },
            files={
                "pdf": pdf,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParsedPageResponse,
                    parse_obj_as(
                        type_=ParsedPageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def translate(
        self,
        *,
        pdf: core.File,
        page_number: typing.Optional[str] = OMIT,
        hard_translate_dict: typing.Optional[str] = OMIT,
        input_lang: typing.Optional[str] = OMIT,
        output_lang: typing.Optional[Language] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[TranslatedPage]:
        """
        Given a PDF, this API helps to translate the content in the document

        Parameters
        ----------
        pdf : core.File
            See core.File for more documentation

        page_number : typing.Optional[str]
            The page number you want to translate. Use a one-based index (e.g., 1 for the first page). You can send an empty value if you want to translate the entire document.

        hard_translate_dict : typing.Optional[str]
            A dictionary of words for which you want to hardcode the translation. A list of words that you want to translate in a specific way. When these words appear in the document, the system will use your custom translation instead of automatic translation.If you add a dictionary with {"Hello": "नमस्कार"}, every time the word "नमस्कार" appears in the document, it will be translated as "नमस्कार" instead of the usual translation.

        input_lang : typing.Optional[str]
            The language code of the input PDF. If you don’t specify, the system will try to detect it automatically.Note:-TranslatePDF currently supports only English language PDFs for translation.

        output_lang : typing.Optional[Language]
            The language code of the output text. This specifies the target language for translation.
            Available options:
            hi = "hi-IN"
            bn = "bn-IN"
            gu = "gu-IN"
            kn = "kn-IN"
            ml = "ml-IN"
            mr = "mr-IN"
            od = "od-IN"
            pa = "pa-IN"
            ta = "ta-IN"
            te = "te-IN"
            Example: "hi-IN" for Hindi

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[TranslatedPage]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "parse/translatepdf",
            method="POST",
            data={
                "page_number": page_number,
                "hard_translate_dict": hard_translate_dict,
                "input_lang": input_lang,
                "output_lang": output_lang,
            },
            files={
                "pdf": pdf,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TranslatedPage,
                    parse_obj_as(
                        type_=TranslatedPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncRawPdfClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def parse(
        self,
        *,
        pdf: core.File,
        page_number: typing.Optional[str] = OMIT,
        sarvam_mode: typing.Optional[SarvamMode] = OMIT,
        prompt_caching: typing.Optional[PromptCaching] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ParsedPageResponse]:
        """
        Given a PDF, this API helps to get structured extraction of data in the document.The API returns a base64 encoded XML string containing the extracted data.

        Parameters
        ----------
        pdf : core.File
            See core.File for more documentation

        page_number : typing.Optional[str]
            The page number you want to extract data from. This is a one-based index (meaning, the first page is 1).

        sarvam_mode : typing.Optional[SarvamMode]
            The mode of parsing to use:

            - small: Use this mode for economical and fast parsing
            - large: Use this mode for highest precision parsing

        prompt_caching : typing.Optional[PromptCaching]
            Whether to cache the prompt for the parse request. This is useful when running multiple requests to the parsing endpoint.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ParsedPageResponse]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "parse/parsepdf",
            method="POST",
            data={
                "page_number": page_number,
                "sarvam_mode": sarvam_mode,
                "prompt_caching": prompt_caching,
            },
            files={
                "pdf": pdf,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ParsedPageResponse,
                    parse_obj_as(
                        type_=ParsedPageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def translate(
        self,
        *,
        pdf: core.File,
        page_number: typing.Optional[str] = OMIT,
        hard_translate_dict: typing.Optional[str] = OMIT,
        input_lang: typing.Optional[str] = OMIT,
        output_lang: typing.Optional[Language] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[TranslatedPage]:
        """
        Given a PDF, this API helps to translate the content in the document

        Parameters
        ----------
        pdf : core.File
            See core.File for more documentation

        page_number : typing.Optional[str]
            The page number you want to translate. Use a one-based index (e.g., 1 for the first page). You can send an empty value if you want to translate the entire document.

        hard_translate_dict : typing.Optional[str]
            A dictionary of words for which you want to hardcode the translation. A list of words that you want to translate in a specific way. When these words appear in the document, the system will use your custom translation instead of automatic translation.If you add a dictionary with {"Hello": "नमस्कार"}, every time the word "नमस्कार" appears in the document, it will be translated as "नमस्कार" instead of the usual translation.

        input_lang : typing.Optional[str]
            The language code of the input PDF. If you don’t specify, the system will try to detect it automatically.Note:-TranslatePDF currently supports only English language PDFs for translation.

        output_lang : typing.Optional[Language]
            The language code of the output text. This specifies the target language for translation.
            Available options:
            hi = "hi-IN"
            bn = "bn-IN"
            gu = "gu-IN"
            kn = "kn-IN"
            ml = "ml-IN"
            mr = "mr-IN"
            od = "od-IN"
            pa = "pa-IN"
            ta = "ta-IN"
            te = "te-IN"
            Example: "hi-IN" for Hindi

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[TranslatedPage]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "parse/translatepdf",
            method="POST",
            data={
                "page_number": page_number,
                "hard_translate_dict": hard_translate_dict,
                "input_lang": input_lang,
                "output_lang": output_lang,
            },
            files={
                "pdf": pdf,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    TranslatedPage,
                    parse_obj_as(
                        type_=TranslatedPage,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
