# coding: utf-8

"""
    Sureel API

    API for the Sureel network.

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.artist_collections_inner_ai_check_results import ArtistCollectionsInnerAiCheckResults
from openapi_client.models.artist_collections_inner_suno_analysis_result_inner import ArtistCollectionsInnerSunoAnalysisResultInner
from openapi_client.models.artist_collections_inner_synthesis_rules import ArtistCollectionsInnerSynthesisRules
from openapi_client.models.collection_status import CollectionStatus
from openapi_client.models.opt_out_analysis import OptOutAnalysis
from openapi_client.models.v1_ai_artist_collection_collection_uuid_get200_response_lyrics_inner import V1AiArtistCollectionCollectionUuidGet200ResponseLyricsInner
from openapi_client.models.v1_ai_artist_collection_collection_uuid_get200_response_stems import V1AiArtistCollectionCollectionUuidGet200ResponseStems
from typing import Optional, Set
from typing_extensions import Self

class V1AiArtistCollectionCollectionUuidGet200Response(BaseModel):
    """
    V1AiArtistCollectionCollectionUuidGet200Response
    """ # noqa: E501
    collection_uuid: StrictStr
    username: StrictStr
    collection_name: Optional[StrictStr] = None
    collection_description: Optional[StrictStr] = None
    upc: Optional[StrictStr] = None
    status: CollectionStatus
    status_description: Optional[StrictStr] = None
    file_ids: Optional[List[StrictStr]] = None
    artworks_s3_keys: Optional[List[StrictStr]] = None
    artworks: Optional[List[StrictStr]] = None
    artworks_full_res: Optional[List[StrictStr]] = Field(default=None, alias="artworksFullRes")
    is_spotify_url: Optional[StrictBool] = None
    prompt_guidance: Optional[StrictStr] = None
    show_in_frontend: Optional[StrictBool] = None
    styles: Optional[List[StrictStr]] = None
    use_for_finetuning: Optional[StrictBool] = None
    use_for_training: Optional[StrictBool] = None
    knowledge_acquisition_ratio: Optional[Union[StrictFloat, StrictInt]] = None
    ai_influence: Optional[StrictStr] = None
    external_id: Optional[StrictStr] = None
    original_cover_art_s3_key: Optional[StrictStr] = None
    original_cover_art: Optional[StrictStr] = None
    audio_language: Optional[StrictStr] = None
    release_date: Optional[StrictStr] = None
    recording_studio: Optional[StrictStr] = None
    publisher: Optional[StrictStr] = None
    producer: Optional[StrictStr] = None
    composer: Optional[StrictStr] = None
    song_writer: Optional[StrictStr] = None
    rights_administrator: Optional[StrictStr] = None
    rights_owner: Optional[StrictStr] = None
    created_at: Optional[Union[StrictFloat, StrictInt]] = None
    updated_at: Optional[Union[StrictFloat, StrictInt]] = None
    collection_published_email_sent: Optional[Union[StrictFloat, StrictInt]] = None
    customer_name: Optional[StrictStr] = None
    lora_weights_s3_key: Optional[StrictStr] = None
    content_type: Optional[StrictStr] = None
    attribution_setup_status: Optional[StrictStr] = None
    suno_analysis_request_ids: Optional[List[StrictStr]] = None
    suno_analysis_result: Optional[List[ArtistCollectionsInnerSunoAnalysisResultInner]] = None
    embeddings_s3_key: Optional[StrictStr] = None
    embeddings_s3_keys: Optional[List[StrictStr]] = None
    external_check_results: Optional[OptOutAnalysis] = None
    internal_check_results: Optional[OptOutAnalysis] = None
    ai_check_results: Optional[ArtistCollectionsInnerAiCheckResults] = None
    synthesis_rules: Optional[ArtistCollectionsInnerSynthesisRules] = None
    label: Optional[StrictStr] = None
    use_for_training_timestamp: Optional[Union[StrictFloat, StrictInt]] = None
    ai_company_notication_status: Optional[StrictStr] = None
    stems: V1AiArtistCollectionCollectionUuidGet200ResponseStems
    lyrics: List[V1AiArtistCollectionCollectionUuidGet200ResponseLyricsInner]
    __properties: ClassVar[List[str]] = ["collection_uuid", "username", "collection_name", "collection_description", "upc", "status", "status_description", "file_ids", "artworks_s3_keys", "artworks", "artworksFullRes", "is_spotify_url", "prompt_guidance", "show_in_frontend", "styles", "use_for_finetuning", "use_for_training", "knowledge_acquisition_ratio", "ai_influence", "external_id", "original_cover_art_s3_key", "original_cover_art", "audio_language", "release_date", "recording_studio", "publisher", "producer", "composer", "song_writer", "rights_administrator", "rights_owner", "created_at", "updated_at", "collection_published_email_sent", "customer_name", "lora_weights_s3_key", "content_type", "attribution_setup_status", "suno_analysis_request_ids", "suno_analysis_result", "embeddings_s3_key", "embeddings_s3_keys", "external_check_results", "internal_check_results", "ai_check_results", "synthesis_rules", "label", "use_for_training_timestamp", "ai_company_notication_status", "stems", "lyrics"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of V1AiArtistCollectionCollectionUuidGet200Response from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of status
        if self.status:
            _dict['status'] = self.status.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in suno_analysis_result (list)
        _items = []
        if self.suno_analysis_result:
            for _item_suno_analysis_result in self.suno_analysis_result:
                if _item_suno_analysis_result:
                    _items.append(_item_suno_analysis_result.to_dict())
            _dict['suno_analysis_result'] = _items
        # override the default output from pydantic by calling `to_dict()` of external_check_results
        if self.external_check_results:
            _dict['external_check_results'] = self.external_check_results.to_dict()
        # override the default output from pydantic by calling `to_dict()` of internal_check_results
        if self.internal_check_results:
            _dict['internal_check_results'] = self.internal_check_results.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ai_check_results
        if self.ai_check_results:
            _dict['ai_check_results'] = self.ai_check_results.to_dict()
        # override the default output from pydantic by calling `to_dict()` of synthesis_rules
        if self.synthesis_rules:
            _dict['synthesis_rules'] = self.synthesis_rules.to_dict()
        # override the default output from pydantic by calling `to_dict()` of stems
        if self.stems:
            _dict['stems'] = self.stems.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in lyrics (list)
        _items = []
        if self.lyrics:
            for _item_lyrics in self.lyrics:
                if _item_lyrics:
                    _items.append(_item_lyrics.to_dict())
            _dict['lyrics'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of V1AiArtistCollectionCollectionUuidGet200Response from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "collection_uuid": obj.get("collection_uuid"),
            "username": obj.get("username"),
            "collection_name": obj.get("collection_name"),
            "collection_description": obj.get("collection_description"),
            "upc": obj.get("upc"),
            "status": CollectionStatus.from_dict(obj["status"]) if obj.get("status") is not None else None,
            "status_description": obj.get("status_description"),
            "file_ids": obj.get("file_ids"),
            "artworks_s3_keys": obj.get("artworks_s3_keys"),
            "artworks": obj.get("artworks"),
            "artworksFullRes": obj.get("artworksFullRes"),
            "is_spotify_url": obj.get("is_spotify_url"),
            "prompt_guidance": obj.get("prompt_guidance"),
            "show_in_frontend": obj.get("show_in_frontend"),
            "styles": obj.get("styles"),
            "use_for_finetuning": obj.get("use_for_finetuning"),
            "use_for_training": obj.get("use_for_training"),
            "knowledge_acquisition_ratio": obj.get("knowledge_acquisition_ratio"),
            "ai_influence": obj.get("ai_influence"),
            "external_id": obj.get("external_id"),
            "original_cover_art_s3_key": obj.get("original_cover_art_s3_key"),
            "original_cover_art": obj.get("original_cover_art"),
            "audio_language": obj.get("audio_language"),
            "release_date": obj.get("release_date"),
            "recording_studio": obj.get("recording_studio"),
            "publisher": obj.get("publisher"),
            "producer": obj.get("producer"),
            "composer": obj.get("composer"),
            "song_writer": obj.get("song_writer"),
            "rights_administrator": obj.get("rights_administrator"),
            "rights_owner": obj.get("rights_owner"),
            "created_at": obj.get("created_at"),
            "updated_at": obj.get("updated_at"),
            "collection_published_email_sent": obj.get("collection_published_email_sent"),
            "customer_name": obj.get("customer_name"),
            "lora_weights_s3_key": obj.get("lora_weights_s3_key"),
            "content_type": obj.get("content_type"),
            "attribution_setup_status": obj.get("attribution_setup_status"),
            "suno_analysis_request_ids": obj.get("suno_analysis_request_ids"),
            "suno_analysis_result": [ArtistCollectionsInnerSunoAnalysisResultInner.from_dict(_item) for _item in obj["suno_analysis_result"]] if obj.get("suno_analysis_result") is not None else None,
            "embeddings_s3_key": obj.get("embeddings_s3_key"),
            "embeddings_s3_keys": obj.get("embeddings_s3_keys"),
            "external_check_results": OptOutAnalysis.from_dict(obj["external_check_results"]) if obj.get("external_check_results") is not None else None,
            "internal_check_results": OptOutAnalysis.from_dict(obj["internal_check_results"]) if obj.get("internal_check_results") is not None else None,
            "ai_check_results": ArtistCollectionsInnerAiCheckResults.from_dict(obj["ai_check_results"]) if obj.get("ai_check_results") is not None else None,
            "synthesis_rules": ArtistCollectionsInnerSynthesisRules.from_dict(obj["synthesis_rules"]) if obj.get("synthesis_rules") is not None else None,
            "label": obj.get("label"),
            "use_for_training_timestamp": obj.get("use_for_training_timestamp"),
            "ai_company_notication_status": obj.get("ai_company_notication_status"),
            "stems": V1AiArtistCollectionCollectionUuidGet200ResponseStems.from_dict(obj["stems"]) if obj.get("stems") is not None else None,
            "lyrics": [V1AiArtistCollectionCollectionUuidGet200ResponseLyricsInner.from_dict(_item) for _item in obj["lyrics"]] if obj.get("lyrics") is not None else None
        })
        return _obj


