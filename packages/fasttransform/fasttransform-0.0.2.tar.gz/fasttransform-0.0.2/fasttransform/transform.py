"""Definitions of `Transform` and `Pipeline`"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_transform.ipynb.

# %% auto 0
__all__ = ['Sig', 'Transform', 'InplaceTransform', 'DisplayedTransform', 'ItemTransform', 'get_func', 'Func', 'compose_tfms',
           'mk_transform', 'gather_attrs', 'gather_attr_names', 'Pipeline']

# %% ../nbs/01_transform.ipynb 1
from typing import Any
import inspect

from fastcore.imports import *
from fastcore.foundation import *
from fastcore.utils import *

from plum import dispatch, Function, NotFoundLookupError

from .cast import *

# %% ../nbs/01_transform.ipynb 6
def _get_name(o):
    if hasattr(o,'__qualname__'): return o.__qualname__
    if hasattr(o,'__name__'): return o.__name__
    return o.__class__.__name__

# %% ../nbs/01_transform.ipynb 7
def _is_tuple(o): return isinstance(o, tuple) and not hasattr(o, '_fields')

# %% ../nbs/01_transform.ipynb 8
_tfm_methods = 'encodes','decodes','setups'
def _is_tfm_method(n, f): return n in _tfm_methods and callable(f)

# %% ../nbs/01_transform.ipynb 9
def _has_self_arg(f) -> bool:
    try: return f.__code__.co_varnames[0] == 'self'
    except (AttributeError, IndexError): return False

# %% ../nbs/01_transform.ipynb 10
def _merge_funcs(*fs):
    "Merge multiple plum Functions by combining their methods"
    fs = fs[::-1]  # overwrite old implementations with new ones
    res = Function(fs[-1].methods[0].implementation)
    for f in fs: 
        for m in f.methods: res.dispatch(m.implementation)
    return res

# %% ../nbs/01_transform.ipynb 12
class _TfmDict(dict):
    def __setitem__(self, k, v):
        if not _is_tfm_method(k, v): return super().__setitem__(k,v)
        if k not in self: super().__setitem__(k, Function(v))
        self[k].dispatch(v)

# %% ../nbs/01_transform.ipynb 13
class _TfmMeta(type):
    @classmethod
    def __prepare__(cls, name, bases): return _TfmDict()

    def __call__(cls, *args, **kwargs):
        if issubclass(cls,Transform) and len(args)==1 and _has_self_arg(args[0]) and len(kwargs)==0: 
            f, nm = args[0], args[0].__name__
            if nm not in _tfm_methods: raise RuntimeError(f"{nm} not in {_tfm_methods}")
            if not hasattr(cls, nm): setattr(cls, nm, Function(f).dispatch(f))
            else: getattr(cls,nm).dispatch(f)
            return cls
        obj = super().__call__(*args, **kwargs)
        # _TfmMeta.__new__ replaces cls.__signature__ which breaks the signature of a callable
        # instances of cls, fix it
        if hasattr(obj, '__call__'): obj.__signature__ = inspect.signature(obj.__call__)
        return obj


    def __new__(cls, name, bases, namespace):
        new_cls = super().__new__(cls, name, bases, namespace)
        for nm in _tfm_methods:
            if hasattr(new_cls, nm):
                funcs = [getattr(new_cls, nm)] + [getattr(b, nm,None) for b in bases]
                funcs = [f for f in funcs if f]
                if funcs: setattr(new_cls, nm, _merge_funcs(*funcs))
        # _TfmMeta.__call__ shadows the signature of inheriting classes, set it back
        new_cls.__signature__ = inspect.signature(new_cls.__init__)
        return new_cls

# %% ../nbs/01_transform.ipynb 14
class Transform(metaclass=_TfmMeta):
    "Delegates (`__call__`,`decode`,`setup`) to (<code>encodes</code>,<code>decodes</code>,<code>setups</code>) if `split_idx` matches"
    split_idx,init_enc,order,train_setup = None,None,0,None
    
    def __init__(self,enc=None,dec=None, split_idx=None, order=None):
        self.split_idx = ifnone(split_idx, self.split_idx)
        self.order = ifnone(order, getattr(self, 'order', 0))
        if not is_listy(enc): 
            self.order = getattr(enc,'order',self.order)
            if len(type_hints(enc)) > 0: self.input_types = union2tuple(first(type_hints(enc).values()))
        if enc:=L(enc): 
                self._name = _get_name(enc[0])
                if not hasattr(enc[0],'__name__'): # Plum requires enc to have __name__ attr
                    f = enc[0]
                    def wrapped_enc(*args,**kwargs): return f(*args,**kwargs)
                    wrapped_enc.__name__ = self._name
                    enc[0] = wrapped_enc
                self.encodes = Function(enc[0])
        for e in enc: self.encodes.dispatch(e)
        if dec:=L(dec): self.decodes = Function(dec[0])
        for d in dec: self.decodes.dispatch(d)

    @property
    def name(self): return getattr(self, '_name', _get_name(self))
    def __repr__(self):
        enc = len(self.encodes.methods) if hasattr(self, 'encodes') else 0
        dec = len(self.decodes.methods) if hasattr(self, 'decodes') else 0
        return f'{self.name}(enc:{enc},dec:{dec})'
    def __call__(self,*args,split_idx=None, **kwargs): return self._call('encodes', *args, split_idx=split_idx, **kwargs)
    def decode(self, *args,split_idx=None, **kwargs): return self._call('decodes', *args, split_idx=split_idx, **kwargs)
    def setup(self, items=None, train_setup=False):
        train_setup = train_setup if self.train_setup is None else self.train_setup
        items = getattr(items, 'train', items) if train_setup else items
        try: return self.setups(items)
        except (AttributeError, NotFoundLookupError): return None

    def _call(self, nm, *args, split_idx=None, **kwargs):
        if split_idx!=self.split_idx and self.split_idx is not None: return args[0]
        if not hasattr(self, nm): return args[0]
        return self._do_call(nm, *args, **kwargs)

    def _do_call(self, nm, *args, **kwargs):
        if _is_tuple(x:=args[0]): 
            res = tuple(self._do_call(nm, x_, *args[1:], **kwargs) for x_ in x)
            return retain_type(res, x, Any)
        f = getattr(self,nm)
        if isinstance(f,MethodType): f, f_args = f._f, (self,)+args
        else: f_args = args
        try: method, ret_type = f._resolve_method_with_cache(f_args)
        except NotFoundLookupError: return x
        return retain_type(method(*f_args,**kwargs), x, ret_type)

add_docs(Transform, decode="Delegate to decodes to undo transform", setup="Delegate to setups to set up transform")

# %% ../nbs/01_transform.ipynb 156
class InplaceTransform(Transform):
    "A `Transform` that modifies in-place and just returns whatever it's passed"
    def _call(self, fn, *args, split_idx=None, **kwargs):
        super()._call(fn,*args, split_idx=split_idx, **kwargs)
        return args[0]

# %% ../nbs/01_transform.ipynb 160
class DisplayedTransform(Transform):
    "A transform with a `__repr__` that shows its attrs"

    @property
    def name(self): return f"{super().name} -- {getattr(self,'__stored_args__',{})}\n"

# %% ../nbs/01_transform.ipynb 166
class ItemTransform(Transform):
    "A transform that always take tuples as items"
    _retain = True
    def __call__(self, x, **kwargs): return self._call1(x, '__call__', **kwargs)
    def decode(self, x, **kwargs):   return self._call1(x, 'decode', **kwargs)
    def _call1(self, x, name, **kwargs):
        if not _is_tuple(x): return getattr(super(), name)(x, **kwargs)
        y = getattr(super(), name)(list(x), **kwargs)
        if not self._retain: return y
        if is_listy(y) and not isinstance(y, tuple): y = tuple(y)
        return retain_type(y, x, Any)
     

# %% ../nbs/01_transform.ipynb 175
def get_func(t, name, *args, **kwargs):
    "Get the `t.name` (potentially partial-ized with `args` and `kwargs`) or `noop` if not defined"
    f = nested_callable(t, name)
    return f if not (args or kwargs) else partial(f, *args, **kwargs)

# %% ../nbs/01_transform.ipynb 179
class Func():
    "Basic wrapper around a `name` with `args` and `kwargs` to call on a given type"
    def __init__(self, name, *args, **kwargs): self.name,self.args,self.kwargs = name,args,kwargs
    def __repr__(self): return f'sig: {self.name}({self.args}, {self.kwargs})'
    def _get(self, t): return get_func(t, self.name, *self.args, **self.kwargs)
    def __call__(self,t): return mapped(self._get, t)

# %% ../nbs/01_transform.ipynb 182
class _Sig():
    def __getattr__(self,k):
        def _inner(*args, **kwargs): return Func(k, *args, **kwargs)
        return _inner

Sig = _Sig()
     

# %% ../nbs/01_transform.ipynb 188
def compose_tfms(x, tfms, is_enc=True, reverse=False, **kwargs):
    "Apply all `func_nm` attribute of `tfms` on `x`, maybe in `reverse` order"
    if reverse: tfms = reversed(tfms)
    for f in tfms:
        if not is_enc: f = f.decode
        x = f(x, **kwargs)
    return x
     

# %% ../nbs/01_transform.ipynb 193
def mk_transform(f):
    "Convert function `f` to `Transform` if it isn't already one"
    f = instantiate(f)
    return f if isinstance(f,(Transform,Pipeline)) else Transform(f)

# %% ../nbs/01_transform.ipynb 194
def gather_attrs(o, k, nm):
    "Used in __getattr__ to collect all attrs `k` from `self.{nm}`"
    if k.startswith('_') or k==nm: raise AttributeError(k)
    att = getattr(o,nm)
    res = [t for t in att.attrgot(k) if t is not None]
    if not res: raise AttributeError(k)
    return res[0] if len(res)==1 else L(res)

# %% ../nbs/01_transform.ipynb 195
def gather_attr_names(o, nm):
    "Used in __dir__ to collect all attrs `k` from `self.{nm}`"
    return L(getattr(o,nm)).map(dir).concat().unique()

# %% ../nbs/01_transform.ipynb 196
class Pipeline:
    "A pipeline of composed (for encode/decode) transforms, setup with types"
    def __init__(self, funcs=None, split_idx=None):
        self.split_idx,self.default = split_idx,None
        if funcs is None: funcs = []
        if isinstance(funcs, Pipeline): self.fs = funcs.fs
        else:
            if isinstance(funcs, Transform): funcs = [funcs]
            self.fs = L(ifnone(funcs,[noop])).map(mk_transform).sorted(key='order')
        for f in self.fs:
            name = camel2snake(type(f).__name__)
            a = getattr(self,name,None)
            if a is not None: f = L(a)+f
            setattr(self, name, f)

    def setup(self, items=None, train_setup=False):
        tfms = self.fs[:]
        self.fs.clear()
        for t in tfms: self.add(t,items, train_setup)

    def add(self,ts, items=None, train_setup=False):
        if not is_listy(ts): ts=[ts]
        for t in ts: t.setup(items, train_setup)
        self.fs+=ts
        self.fs = self.fs.sorted(key='order')

    def __call__(self, o): return compose_tfms(o, tfms=self.fs, split_idx=self.split_idx)
    def __repr__(self): return f"Pipeline: {' -> '.join([f.name for f in self.fs if f.name != 'noop'])}"
    def __getitem__(self,i): return self.fs[i]
    def __setstate__(self,data): self.__dict__.update(data)
    def __getattr__(self,k): return gather_attrs(self, k, 'fs')
    def __dir__(self): return super().__dir__() + gather_attr_names(self, 'fs')

    def decode  (self, o, full=True):
        if full: return compose_tfms(o, tfms=self.fs, is_enc=False, reverse=True, split_idx=self.split_idx)
        #Not full means we decode up to the point the item knows how to show itself.
        for f in reversed(self.fs):
            if self._is_showable(o): return o
            o = f.decode(o, split_idx=self.split_idx)
        return o

    def show(self, o, ctx=None, **kwargs):
        o = self.decode(o, full=False)
        o1 = (o,) if not _is_tuple(o) else o
        if hasattr(o, 'show'): ctx = o.show(ctx=ctx, **kwargs)
        else:
            for o_ in o1:
                if hasattr(o_, 'show'): ctx = o_.show(ctx=ctx, **kwargs)
        return ctx

    def _is_showable(self, o):
        if hasattr(o, 'show'): return True
        if _is_tuple(o): return all(hasattr(o_, 'show') for o_ in o)
        return False
