"""Type casting utility functions"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_cast.ipynb.

# %% auto 0
__all__ = ['retain_meta', 'default_set_meta', 'cast', 'retain_type', 'retain_types', 'explode_types']

# %% ../nbs/00_cast.ipynb 1
from typing import Any

from plum import dispatch, Function
from numpy import ndarray

from fastcore.imports import *
from fastcore.foundation import *
from fastcore.utils import *

# %% ../nbs/00_cast.ipynb 6
def retain_meta(x, res, as_copy=False):
    "Call `res.set_meta(x)`, if it exists"
    if hasattr(res,'set_meta'): res.set_meta(x, as_copy=as_copy)
    return res
     

# %% ../nbs/00_cast.ipynb 7
def default_set_meta(self, x, as_copy=False):
    "Copy over `_meta` from `x` to `res`, if it's missing"
    if hasattr(x, '_meta') and not hasattr(self, '_meta'):
        meta = x._meta
        if as_copy: meta = copy(meta)
        self._meta = meta
    return self
     

# %% ../nbs/00_cast.ipynb 8
def cast(x, typ):
    "cast `x` to type `typ` (may also change `x` inplace)"
    res = typ._before_cast(x) if hasattr(typ, '_before_cast') else x
    if risinstance('ndarray', res): res = res.view(typ)
    elif hasattr(res, 'as_subclass'): res = res.as_subclass(typ)
    else:
        try: res.__class__ = typ
        except: res = typ(res)
    return retain_meta(x, res)

# %% ../nbs/00_cast.ipynb 15
def retain_type(new, old, ret_type=Any,as_copy=False):
    "Cast `new` to `ret_type` if given, or `old`'s type if `new` is a superclass of `old`. No conversion is done if `ret_type=None`"
    if new is None: return new
    if ret_type is NoneType: return new
    if ret_type is Any:
        if not isinstance(old, type(new)): return new
        ret_type = old if isinstance(old,type) else type(old)
    if ret_type is NoneType or isinstance(new,ret_type): return new
    return retain_meta(old, cast(new, ret_type), as_copy=as_copy)   

# %% ../nbs/00_cast.ipynb 40
def retain_types(new, old=None, typs=None):
    "Cast each item of `new` to type of matching item in `old` if it's a superclass"
    if not is_listy(new): 
        typs = Any if typs is None else typs  # make fasttransform.utils.retain_type compatible
        return retain_type(new, old,typs)
    if typs is not None:
        if isinstance(typs, dict):
            t = first(typs.keys())
            typs = typs[t]
        else: t,typs = typs,None
    else: t = type(old) if old is not None and isinstance(old,type(new)) else type(new)
    return t(L(new, old, typs).map_zip(retain_types, cycled=True))
     

# %% ../nbs/00_cast.ipynb 42
def explode_types(o):
    "Return the type of `o`, potentially in nested dictionaries for thing that are listy"
    if not is_listy(o): return type(o)
    return {type(o): [explode_types(o_) for o_ in o]}
