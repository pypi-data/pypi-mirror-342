import ast
import os
import textwrap


class BoilerplateManager:
    """
    Handles boilerplate additions for dynamically generated test scripts.
    """

    def __init__(self, is_method=False, class_code=None):
        """
        Initializes the BoilerplateManager.

        Args:
            is_method (bool): Indicates if the target is a method.
            class_code (str): The full class definition (if applicable).
        """
        self.is_method = is_method
        self.class_code = class_code

    def add_boilerplate(self, test_code, function_name, import_path, script_dir):
        """
        Adds necessary imports and execution logic to the test code.

        Args:
            test_code (str): The core test code generated by the LLM.
            function_name (str): The name of the function or method being tested.
            import_path (str): The full path to the dynamic file.
            script_dir (str): The directory where the test file is being saved.

        Returns:
            str: The complete test script with boilerplate added.
        """
        # Convert the full import path to a relative import
        relative_import_path = os.path.relpath(import_path, script_dir).replace("\\", "/")
        if relative_import_path.endswith(".py"):
            relative_import_path = relative_import_path[:-3]  # Remove `.py` extension
        relative_import_path = relative_import_path.replace("/", ".")

        if self.is_method:
            return self._generate_class_based_test(test_code, function_name, relative_import_path)
        else:
            return self._generate_function_based_test(test_code, function_name, relative_import_path)

    def _generate_function_based_test(self, test_code, function_name, relative_import_path):
        """
        Generates test code for standalone functions.

        Args:
            test_code (str): The core test code.
            function_name (str): The function name.
            relative_import_path (str): The relative import path.

        Returns:
            str: The complete test script.
        """
        boilerplate = f"""
import unittest
from {relative_import_path} import {function_name}

{textwrap.dedent(test_code)}

if __name__ == "__main__":
    unittest.main()
"""
        return textwrap.dedent(boilerplate)

    def _generate_class_based_test(self, test_code, function_name, relative_import_path):
        """
        Generates test code for methods within a class.

        Args:
            test_code (str): The core test code.
            function_name (str): The method name.
            relative_import_path (str): The relative import path.

        Returns:
            str: The complete test script.
        """
        if not self.class_code:
            raise ValueError("Class code must be provided for method-based tests.")

        # Parse the class code into an AST
        tree = ast.parse(self.class_code)

        # Find the target class and replace the method with an import statement
        for node in tree.body:
            if isinstance(node, ast.ClassDef):
                for i, method in enumerate(node.body):
                    if isinstance(method, ast.FunctionDef) and method.name == function_name:
                        # Replace the method with an import statement
                        import_node = ast.parse(f"from {relative_import_path} import {function_name}").body[0]
                        node.body[i] = import_node
                        break

        # Unparse the modified AST back to Python code
        modified_class_code = ast.unparse(tree)

        boilerplate = f"""
import unittest

{textwrap.dedent(modified_class_code)}

{textwrap.dedent(test_code)}

if __name__ == "__main__":
    unittest.main()
"""
        return textwrap.dedent(boilerplate)


# class BoilerplateManager:
#     """
#     Handles boilerplate additions for dynamically generated test scripts.
#     """

#     def __init__(self, is_method=False, class_code=None):
#         """
#         Initializes the BoilerplateManager.

#         Args:
#             is_method (bool): Indicates if the target is a method.
#             class_code (str): The full class definition (if applicable).
#         """
#         self.is_method = is_method
#         self.class_code = class_code

#     def add_boilerplate(self, test_code, function_name, import_path):
#         """
#         Adds necessary imports and execution logic to the test code.

#         Args:
#             test_code (str): The core test code generated by the LLM.
#             function_name (str): The name of the function being tested.
#             import_path (str): The path to the dynamic function file.

#         Returns:
#             str: The complete test script with boilerplate added.
#         """
#         if self.is_method:
#             return self._generate_class_based_test(test_code, function_name, import_path)
#         else:
#             return self._generate_function_based_test(test_code, function_name, import_path)

#     def _generate_function_based_test(self, test_code, function_name, import_path):
#         """
#         Generates test code for standalone functions.

#         Args:
#             test_code (str): The core test code.
#             function_name (str): The function name.
#             import_path (str): The import path.

#         Returns:
#             str: The complete test script.
#         """
#         boilerplate = f"""
# import unittest
# from {import_path} import {function_name}

# {textwrap.dedent(test_code)}

# if __name__ == "__main__":
#     unittest.main()
# """
#         return textwrap.dedent(boilerplate)

#     def _generate_class_based_test(self, test_code, function_name, import_path):
#         """
#         Generates test code for methods within a class.

#         Args:
#             test_code (str): The core test code.
#             function_name (str): The method name.
#             import_path (str): The import path.

#         Returns:
#             str: The complete test script.
#         """
#         if not self.class_code:
#             raise ValueError("Class code must be provided for method-based tests.")

#         # Parse the class code into an AST
#         tree = ast.parse(self.class_code)

#         # Find the target class and method
#         for node in tree.body:
#             if isinstance(node, ast.ClassDef):
#                 # Locate the method within the class
#                 for i, method in enumerate(node.body):
#                     if isinstance(method, ast.FunctionDef) and method.name == function_name:
#                         # Replace the method with an import statement
#                         import_node = ast.parse(f"from {import_path} import {function_name}").body[0]
#                         node.body[i] = import_node
#                         break

#         # Unparse the modified AST back to Python code
#         modified_class_code = ast.unparse(tree)

#         boilerplate = f"""
# import unittest

# {textwrap.dedent(modified_class_code)}

# {textwrap.dedent(test_code)}

# if __name__ == "__main__":
#     unittest.main()
# """
#         return textwrap.dedent(boilerplate)

# class BoilerplateManager:
#     """
#     Handles boilerplate additions for dynamically generated test scripts.
#     """

#     @staticmethod
#     def add_boilerplate(test_code, function_name, import_path):
#         """
#         Adds necessary imports and execution logic to the test code.

#         Args:
#             test_code (str): The core test code generated by the LLM.
#             function_name (str): The name of the function being tested.
#             import_path (str): The path to the dynamic function file.

#         Returns:
#             str: The complete test script with boilerplate added.
#         """
#         boilerplate = f"""
# import unittest
# from {import_path} import {function_name}

# {textwrap.dedent(test_code)}

# if __name__ == "__main__":
#     unittest.main()
# """
#         return textwrap.dedent(boilerplate)


# class BoilerplateManager:
#     """
#     Handles boilerplate additions for dynamically generated test scripts.
#     """

#     @staticmethod
#     def add_boilerplate(test_code, function_name, import_path):
#         """
#         Adds imports and execution logic to the test code.

#         Args:
#             test_code (str): The core test code generated by the LLM.
#             function_name (str): The name of the function being tested.
#             import_path (str): The import path for the function or class being tested.

#         Returns:
#             str: The complete test script with boilerplate added.
#         """
#         # Add import for unittest and the tested function
#         boilerplate = f"""
# import unittest
# from {import_path} import {function_name}

# {test_code}

# if __name__ == "__main__":
#     unittest.main()
# """
#         return textwrap.dedent(boilerplate)


# test_core_code = """
# class TestCalculateAverage(unittest.TestCase):
#     def test_normal_cases(self):
#         self.assertEqual(calculate_average([1, 2, 3]), 2.0)
#         self.assertEqual(calculate_average([-1, -2, -3]), -2.0)

#     def test_edge_cases(self):
#         self.assertEqual(calculate_average([]), 0.0)
#         self.assertEqual(calculate_average([5]), 5.0)
# """

# # Add boilerplate
# manager = BoilerplateManager()
# full_test_script = manager.add_boilerplate(test_core_code, "calculate_average", "dynamic_file")
# print(full_test_script)

