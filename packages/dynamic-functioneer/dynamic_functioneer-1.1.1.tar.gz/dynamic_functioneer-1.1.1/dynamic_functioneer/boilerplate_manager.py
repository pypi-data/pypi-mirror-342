import ast
import os
import textwrap


class BoilerplateManager:
    """
    Handles boilerplate generation for dynamically created test scripts.

    This class can generate two types of boilerplate test code:
      1. For standalone functions (function-based tests).
      2. For class methods (class-based tests).

    Attributes:
        is_method (bool):
            Indicates if the target is a method (True) or a standalone function (False).
        class_code (str):
            The full class definition (if applicable). Only used when is_method=True.
    """

    def __init__(self, is_method: bool = False, class_code: str = None):
        """
        Initialize the BoilerplateManager.

        Args:
            is_method (bool, optional):
                Indicates if the target is a method (True) or standalone function (False).
                Defaults to False.

            class_code (str, optional):
                The full class definition (if applicable). Used only when `is_method` is True.
                Defaults to None.
        """
        self.is_method = is_method
        self.class_code = class_code

    def add_boilerplate(
        self,
        test_code: str,
        function_name: str,
        import_path: str,
        script_dir: str
    ) -> str:
        """
        Adds the necessary imports and execution logic to the test code.

        It creates a relative import path to the dynamic file, then generates either
        function-based or class-based test boilerplate depending on `self.is_method`.

        Args:
            test_code (str):
                The core test code generated by the LLM.
            function_name (str):
                The name of the function or method being tested.
            import_path (str):
                The full path (absolute or relative) to the dynamic file
                containing the function or method.
            script_dir (str):
                The directory where the test file will be saved (used to compute relative imports).

        Returns:
            str: The complete test script with boilerplate code.
        """
        # Basic validation
        if not test_code or not test_code.strip():
            raise ValueError("Test code is missing or empty.")

        # Compute relative import path from script_dir to import_path
        relative_import_path = os.path.relpath(import_path, script_dir).replace("\\", "/")
        if relative_import_path.endswith(".py"):
            relative_import_path = relative_import_path[:-3]  # Remove `.py` extension
        relative_import_path = relative_import_path.replace("/", ".")

        if self.is_method:
            return self._generate_class_based_test(
                test_code=test_code,
                function_name=function_name,
                relative_import_path=relative_import_path
            )
        else:
            return self._generate_function_based_test(
                test_code=test_code,
                function_name=function_name,
                relative_import_path=relative_import_path
            )

    def _generate_function_based_test(
        self,
        test_code: str,
        function_name: str,
        relative_import_path: str
    ) -> str:
        """
        Generates the boilerplate test code for a standalone function.

        Args:
            test_code (str):
                The core test code (usually containing a unittest.TestCase subclass).
            function_name (str):
                The name of the standalone function under test.
            relative_import_path (str):
                The relative import path to the module containing the function.

        Returns:
            str: The complete test script with imports and unittest main block.
        """
        boilerplate = f"""
import unittest
from {relative_import_path} import {function_name}

{textwrap.dedent(test_code)}

if __name__ == "__main__":
    unittest.main()
"""
        return textwrap.dedent(boilerplate)

    def _generate_class_based_test(
        self,
        test_code: str,
        function_name: str,
        relative_import_path: str
    ) -> str:
        """
        Generates the boilerplate test code for a method within a class.

        This replaces the method definition in the class code with an import statement
        so that the dynamic method is tested instead of any existing local definition.

        Args:
            test_code (str):
                The core test code (usually containing a unittest.TestCase subclass).
            function_name (str):
                The name of the method under test.
            relative_import_path (str):
                The relative import path to the module containing the method.

        Returns:
            str: The complete test script with the updated class definition and unittest main block.

        Raises:
            ValueError:
                If class_code is missing (because we need it to generate class-based tests).
        """
        if not self.class_code:
            raise ValueError("Class code must be provided for method-based tests.")

        # Parse the class_code into an AST
        try:
            tree = ast.parse(self.class_code)
        except SyntaxError as e:
            raise ValueError(f"Failed to parse class code: {e}")

        # Attempt to replace the specified method with an import statement
        for node in tree.body:
            if isinstance(node, ast.ClassDef):
                for i, child_node in enumerate(node.body):
                    if isinstance(child_node, ast.FunctionDef) and child_node.name == function_name:
                        # Replace the method with an import statement
                        import_node = ast.parse(
                            f"from {relative_import_path} import {function_name}"
                        ).body[0]
                        node.body[i] = import_node
                        break

        # Unparse the modified AST back to Python code
        try:
            modified_class_code = ast.unparse(tree)
        except AttributeError as e:
            raise ValueError(
                "Your Python version does not support 'ast.unparse'. "
                "Please upgrade to Python 3.9+ or manually handle the AST changes."
            ) from e

        # Build the final boilerplate
        boilerplate = f"""
import unittest

{textwrap.dedent(modified_class_code)}

{textwrap.dedent(test_code)}

if __name__ == "__main__":
    unittest.main()
"""
        return textwrap.dedent(boilerplate)
