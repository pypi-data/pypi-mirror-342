"""
Identities are random tokens, with a prefix that identifies what they are used for.

An identity consists of a qualifier (such as "app", "apikey" etc) followed by a hyphen and
random digits. There is enough random digits to ensure that classes are highlight improbable.

QUALIFIER-RANDOMDIGITS

The random digits are encoded as Crockford's Base32. 

This scheme is suitable for inclusion in URLs.

"""

import os
from typing import NewType, Final


class IdentityError(Exception):
    """Raised when there are errors in the identifiers."""


SEPARATOR = "-"
IDENTITY_ALPHABET = "0123456789ABCDEFGHJKMNPQRSTUVWYZ"
IDENTITY_SIZE = 12


_NORMALIZE_TABLE = str.maketrans(
    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    "0123456789ABCDEFGH1JK1MN0PQRSTUVWXYZABCDEFGH1JKM1N0PQRSTUVWXYZ",
)

AccountIdentity = NewType("AccountIdentity", str)
ApplicationIdentity = NewType("ApplicationIdentity", str)
WebClientIdentity = NewType("WebClientIdentity", str)
ClientIdentity = NewType("ClientIdentity", str)
ApplicationClientIdentity = NewType("ApplicationClientIdentity", str)
APIKeyIdentity = NewType("APIKeyIdentity", str)
SessionIdentity = NewType("SessionIdentity", str)
UserIdentity = NewType("UserIdentity", str)

QUALIFY_APPLICATION: Final = "app"
QUALIFY_WEB_CLIENT: Final = "web"
QUALIFY_APPLICATION_CLIENT: Final = "appclient"
QUALIFY_CLIENT: Final = "client"
QUALIFY_ACCOUNT: Final = "acc"
QUALIFY_APIKEY: Final = "apikey"
QUALIFY_SESSION: Final = "session"
QUALIFY_USER: Final = "user"


def generate(size: int = IDENTITY_SIZE) -> str:
    """Generate a random identifier."""
    alphabet = IDENTITY_ALPHABET
    return "".join(alphabet[byte % 31] for byte in os.urandom(size))


def normalize(identity: str) -> str:
    """Normalize an identity (qualified or unqualified).

    Args:
        identity: An identity.

    Returns:
        Normalized identity.
    """
    qualifier, identifier = parse(identity)
    normalized_identifier = identifier.translate(_NORMALIZE_TABLE)
    if qualifier:
        return format(qualifier, normalized_identifier)
    else:
        return normalized_identifier


def parse(identity: str) -> tuple[str, str]:
    """Parse an identity in to a qualifier and identifier.

    Returns:
        Tuple of qualifier and identifier.
    """
    qualifier, divider, identifier = identity.partition(SEPARATOR)
    if not divider:
        return "", identity
    return qualifier, identifier


def parse_qualifier(identity: str) -> str:
    """Parse out just the qualifier.

    Args:
        identity: An identity.

    Returns:
        str: Qualifier.
    """
    return parse(identity)[0]


def is_qualified(identity: str, qualifier: str) -> bool:
    """Check the identity has the given qualifier.

    Args:
        identity: An identity.
        qualifier: Required qualifier.

    Returns:
        True if the qualifier matches, otherwise False.
    """
    return parse_qualifier(identity) == qualifier


def qualify(identity: str, new_qualifier: str) -> str:
    """Qualify an identity.

    Args:
        identity: An un-qualified identity
        new_qualifier: Replacement qualifier

    Raises:
        IdentityError: If `identity` is already qualified.

    Returns:
        A new qualified identity.
    """
    if SEPARATOR in identity:
        raise IdentityError(f"identity {identity!r} is already qualified")
    return format(new_qualifier, identity)


def unqualify(identity: str) -> str:
    """Remove any qualifier.

    Args:
        identity: An identity.

    Returns:
        A non-qualified identity.
    """
    return parse(identity)[1]


def format(qualifier: str, identifier: str) -> str:
    """Format a new identity.

    Args:
        qualifier: Qualify string.
        identifier: Identifier (random digits generated by `generate`).

    Returns:
        Fully qualified identity.
    """
    return f"{qualifier}{SEPARATOR}{identifier}"


def create(qualifier: str) -> str:
    """Generate a new identity.

    Args:
        qualifier: Qualifier prefix.

    Returns:
        new identity.
    """
    return format(qualifier, generate())


def new_application() -> ApplicationIdentity:
    """Create a new application identity."""
    return ApplicationIdentity(create(QUALIFY_APPLICATION))


def new_web() -> WebClientIdentity:
    """Create a new application identity."""
    return WebClientIdentity(create(QUALIFY_WEB_CLIENT))


def new_application_client() -> ApplicationClientIdentity:
    """Create a new app client identity."""
    return ApplicationClientIdentity(create(QUALIFY_APPLICATION_CLIENT))


def new_client() -> ClientIdentity:
    """Create a new instance identity."""
    return ClientIdentity(create(QUALIFY_CLIENT))


def new_account() -> AccountIdentity:
    """Create a new instance identity."""
    return AccountIdentity(create(QUALIFY_ACCOUNT))


def new_apikey() -> APIKeyIdentity:
    """Create a new api key indentity."""
    return APIKeyIdentity(create(QUALIFY_APIKEY))


def new_session() -> SessionIdentity:
    """Create a new session identity."""
    return SessionIdentity(create(QUALIFY_SESSION))


def new_user() -> UserIdentity:
    """Create a new user identity.s"""
    return UserIdentity(create(QUALIFY_USER))


if __name__ == "__main__":
    print(new_application())
