# tests/test_melli_code.py

import pytest
import re
from melli_code import (
    is_valid,
    validate,
    generate,
    InvalidNationalCode,
)

# --- Corrected Test Data ---

# Manually Verified Valid Codes
# 0012345679: Sum=112, Rem=2. Check=9. Expect 11-2=9. Valid.
# 1234567891: Sum=210, Rem=1. Check=1. Expect 1. Valid.

# Add a few codes generated by the library itself.
# The 'test_generate_produces_valid_codes' test will ensure these pass is_valid.
# We call generate() here so the list contains actual generated codes for the parametrize tests.
generated_valid_codes = {generate() for _ in range(3)} # Use set to ensure uniqueness if needed

VALID_CODES = [
    "0012345679",
    "1234567891",
] + list(generated_valid_codes)


# Manually Verified Invalid Checksum Codes
# 0012345678: Sum=112, Rem=2. Check=8. Expect 11-2=9. Invalid.
# 1234567890: Sum=210, Rem=1. Check=0. Expect 1. Invalid.
# 2659168811: Sum=271, Rem=7. Check=1. Expect 11-7=4. Invalid.
# 0499377628: Sum=274, Rem=10. Check=8. Expect 11-10=1. Invalid.
INVALID_CHECKSUM_CODES = [
    "0012345678",
    "1234567890",
    "2659168811",
    "0499377628",
]

# These remain the same
INVALID_FORMAT_CODES = [
    "12345",        # Too short
    "00123456789",  # Too long
    "001234567a",  # Contains non-digit
    " 0012345679", # Leading space
    "0012345679 ", # Trailing space
    "",             # Empty string
    None,           # Not a string
    1234567890,     # Integer type
]

INVALID_ALL_SAME_DIGITS = [
    "0000000000",
    "1111111111",
    "2222222222",
    "3333333333",
    "4444444444",
    "5555555555",
    "6666666666",
    "7777777777",
    "8888888888",
    "9999999999",
]

# --- Test Functions (No changes needed below this line) ---

# Test is_valid() function
# -----------------------

@pytest.mark.parametrize("code", VALID_CODES)
def test_is_valid_true_for_valid_codes(code):
    """Test that is_valid returns True for known valid codes."""
    assert is_valid(code) is True, f"is_valid failed for supposedly valid code: {code}"

@pytest.mark.parametrize("code", INVALID_CHECKSUM_CODES)
def test_is_valid_false_for_invalid_checksum(code):
    """Test that is_valid returns False for codes with incorrect checksum."""
    assert is_valid(code) is False, f"is_valid returned True for invalid checksum code: {code}"

@pytest.mark.parametrize("code", INVALID_FORMAT_CODES)
def test_is_valid_false_for_invalid_format(code):
    """Test that is_valid returns False for codes with invalid format."""
    assert is_valid(code) is False, f"is_valid returned True for invalid format code: {code}"

@pytest.mark.parametrize("code", INVALID_ALL_SAME_DIGITS)
def test_is_valid_false_for_all_same_digits(code):
    """Test that is_valid returns False for codes with all identical digits."""
    assert is_valid(code) is False, f"is_valid returned True for all-same-digits code: {code}"

# Test validate() function
# ------------------------

@pytest.mark.parametrize("code", VALID_CODES)
def test_validate_passes_for_valid_codes(code):
    """Test that validate does not raise an exception for valid codes."""
    try:
        validate(code)
    except InvalidNationalCode as e:
        pytest.fail(f"validate() raised InvalidNationalCode unexpectedly for valid code '{code}': {e}")

@pytest.mark.parametrize("code", INVALID_CHECKSUM_CODES)
def test_validate_raises_for_invalid_checksum(code):
    """Test that validate raises InvalidNationalCode for incorrect checksum."""
    with pytest.raises(InvalidNationalCode, match=r"Invalid checksum"):
        validate(code)

@pytest.mark.parametrize("code", INVALID_FORMAT_CODES)
def test_validate_raises_for_invalid_format(code):
    """Test that validate raises InvalidNationalCode for invalid format."""
    # Refined matching for better error messages on failure
    expected_msg = f"Invalid format: Input '{code}' must be a 10-digit string."
    with pytest.raises(InvalidNationalCode) as excinfo:
        validate(code)
    # Check if the expected message is part of the actual exception message
    assert "Invalid format" in str(excinfo.value)
    # For more specific check uncomment below, but might be too brittle for None/int inputs
    # assert str(excinfo.value) == expected_msg


@pytest.mark.parametrize("code", INVALID_ALL_SAME_DIGITS)
def test_validate_raises_for_all_same_digits(code):
    """Test that validate raises InvalidNationalCode for all identical digits."""
    with pytest.raises(InvalidNationalCode, match=r"consists of all identical digits"):
        validate(code)

# Test generate() function
# ------------------------

def test_generate_produces_valid_codes():
    """Test that generate() produces a valid 10-digit string code."""
    # Generate a few codes and check each one
    for i in range(20): # Generate and test 20 random codes
        generated_code = generate()
        assert isinstance(generated_code, str), f"Generated code {i} is not a string: {generated_code!r}"
        assert len(generated_code) == 10, f"Generated code {i} '{generated_code}' length is not 10"
        assert re.match(r'^\d{10}$', generated_code), f"Generated code {i} '{generated_code}' contains non-digits"
        # The crucial check: ensure the generated code passes our own validation
        assert is_valid(generated_code), f"Generated code {i} '{generated_code}' failed validation check by is_valid()"
        # Also test that validate() doesn't raise an error
        try:
            validate(generated_code)
        except InvalidNationalCode as e:
             pytest.fail(f"validate() raised InvalidNationalCode for generated code {i} '{generated_code}': {e}")


def test_generate_produces_different_codes():
    """Test that generate() likely produces different codes on subsequent calls."""
    # It's probabilistic, but highly unlikely to get the same code many times.
    generated_codes = set(generate() for _ in range(20))
    # If we generated 20 codes, we expect more than just a few unique ones
    # Increase threshold slightly for robustness
    assert len(generated_codes) > 10, f"Generated codes are not sufficiently varied (only {len(generated_codes)} unique out of 20)"