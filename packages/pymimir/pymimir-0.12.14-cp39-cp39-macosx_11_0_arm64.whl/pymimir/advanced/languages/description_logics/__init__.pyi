from collections.abc import Iterable, Iterator, Mapping
import enum
from typing import overload

import pymimir


class Boolean:
    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def evaluate(self, evaluation_context: "mimir::languages::dl::EvaluationContext") -> "mimir::languages::dl::DenotationImpl<mimir::languages::dl::BooleanTag>": ...

    def accept(self, visitor: ConstructorVisitor) -> None: ...

    def get_index(self) -> int: ...

class BooleanConceptNonempty(Boolean):
    def get_constructor(self) -> Concept: ...

class BooleanDerivedAtomicState(Boolean):
    def get_predicate(self) -> pymimir.advanced.formalism.DerivedPredicate: ...

class BooleanFluentAtomicState(Boolean):
    def get_predicate(self) -> pymimir.advanced.formalism.FluentPredicate: ...

class BooleanList:
    @overload
    def __init__(self) -> None:
        """Default constructor"""

    @overload
    def __init__(self, arg: BooleanList) -> None:
        """Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[Boolean], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __repr__(self) -> str: ...

    def __iter__(self) -> Iterator[Boolean]: ...

    @overload
    def __getitem__(self, arg: int, /) -> Boolean: ...

    @overload
    def __getitem__(self, arg: slice, /) -> BooleanList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: Boolean, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: Boolean, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> Boolean:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: BooleanList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: Boolean, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: BooleanList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def __eq__(self, arg: object, /) -> bool: ...

    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: Boolean, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: Boolean, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: Boolean, /) -> None:
        """Remove first occurrence of `arg`."""

class BooleanRoleNonempty(Boolean):
    def get_constructor(self) -> Role: ...

class BooleanStaticAtomicState(Boolean):
    def get_predicate(self) -> pymimir.advanced.formalism.StaticPredicate: ...

class CNFGrammar:
    def __init__(self, bnf_description: str, domain: pymimir.advanced.formalism.Domain) -> None: ...

    @staticmethod
    def create(type: GrammarSpecificationEnum, domain: pymimir.advanced.formalism.Domain) -> CNFGrammar: ...

    def __str__(self) -> str: ...

    def accept(self, visitor: "mimir::languages::dl::cnf_grammar::IVisitor") -> None: ...

    @overload
    def test_match(self, arg: Numerical, /) -> bool: ...

    @overload
    def test_match(self, arg: Role, /) -> bool: ...

    @overload
    def test_match(self, arg: Boolean, /) -> bool: ...

    @overload
    def test_match(self, arg: Numerical, /) -> bool: ...

    def get_repositories(self) -> "mimir::languages::dl::cnf_grammar::Repositories": ...

    def get_domain(self) -> pymimir.advanced.formalism.Domain: ...

class Concept:
    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def evaluate(self, evaluation_context: "mimir::languages::dl::EvaluationContext") -> "mimir::languages::dl::DenotationImpl<mimir::languages::dl::ConceptTag>": ...

    def accept(self, visitor: ConstructorVisitor) -> None: ...

    def get_index(self) -> int: ...

class ConceptBot(Concept):
    pass

class ConceptDerivedAtomicGoal(Concept):
    def get_predicate(self) -> pymimir.advanced.formalism.DerivedPredicate: ...

    def get_polarity(self) -> bool: ...

class ConceptDerivedAtomicState(Concept):
    def get_predicate(self) -> pymimir.advanced.formalism.DerivedPredicate: ...

class ConceptExistentialQuantification(Concept):
    def get_role(self) -> Role: ...

    def get_concept(self) -> Concept: ...

class ConceptFluentAtomicGoal(Concept):
    def get_predicate(self) -> pymimir.advanced.formalism.FluentPredicate: ...

    def get_polarity(self) -> bool: ...

class ConceptFluentAtomicState(Concept):
    def get_predicate(self) -> pymimir.advanced.formalism.FluentPredicate: ...

class ConceptIntersection(Concept):
    def get_left_concept(self) -> Concept: ...

    def get_right_concept(self) -> Concept: ...

class ConceptList:
    @overload
    def __init__(self) -> None:
        """Default constructor"""

    @overload
    def __init__(self, arg: ConceptList) -> None:
        """Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[Concept], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __repr__(self) -> str: ...

    def __iter__(self) -> Iterator[Concept]: ...

    @overload
    def __getitem__(self, arg: int, /) -> Concept: ...

    @overload
    def __getitem__(self, arg: slice, /) -> ConceptList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: Concept, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: Concept, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> Concept:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: ConceptList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: Concept, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: ConceptList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def __eq__(self, arg: object, /) -> bool: ...

    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: Concept, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: Concept, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: Concept, /) -> None:
        """Remove first occurrence of `arg`."""

class ConceptNegation(Concept):
    def get_concept(self) -> Concept: ...

class ConceptNominal(Concept):
    def get_object(self) -> pymimir.advanced.formalism.Object: ...

class ConceptRoleValueMapContainment(Concept):
    def get_left_role(self) -> Role: ...

    def get_right_role(self) -> Role: ...

class ConceptRoleValueMapEquality(Concept):
    def get_left_role(self) -> Role: ...

    def get_right_role(self) -> Role: ...

class ConceptStaticAtomicGoal(Concept):
    def get_predicate(self) -> pymimir.advanced.formalism.StaticPredicate: ...

    def get_polarity(self) -> bool: ...

class ConceptStaticAtomicState(Concept):
    def get_predicate(self) -> pymimir.advanced.formalism.StaticPredicate: ...

class ConceptTop(Concept):
    pass

class ConceptUnion(Concept):
    def get_left_concept(self) -> Concept: ...

    def get_right_concept(self) -> Concept: ...

class ConceptValueRestriction(Concept):
    def get_role(self) -> Role: ...

    def get_concept(self) -> Concept: ...

class ConstructorVisitor:
    def __init__(self) -> None: ...

    @overload
    def visit(self, arg: ConceptBot, /) -> None: ...

    @overload
    def visit(self, arg: ConceptTop, /) -> None: ...

    @overload
    def visit(self, arg: ConceptStaticAtomicState, /) -> None: ...

    @overload
    def visit(self, arg: ConceptFluentAtomicState, /) -> None: ...

    @overload
    def visit(self, arg: ConceptDerivedAtomicState, /) -> None: ...

    @overload
    def visit(self, arg: ConceptStaticAtomicGoal, /) -> None: ...

    @overload
    def visit(self, arg: ConceptFluentAtomicGoal, /) -> None: ...

    @overload
    def visit(self, arg: ConceptDerivedAtomicGoal, /) -> None: ...

    @overload
    def visit(self, arg: ConceptIntersection, /) -> None: ...

    @overload
    def visit(self, arg: ConceptUnion, /) -> None: ...

    @overload
    def visit(self, arg: ConceptNegation, /) -> None: ...

    @overload
    def visit(self, arg: ConceptValueRestriction, /) -> None: ...

    @overload
    def visit(self, arg: ConceptExistentialQuantification, /) -> None: ...

    @overload
    def visit(self, arg: ConceptRoleValueMapContainment, /) -> None: ...

    @overload
    def visit(self, arg: ConceptRoleValueMapEquality, /) -> None: ...

    @overload
    def visit(self, arg: ConceptNominal, /) -> None: ...

    @overload
    def visit(self, arg: RoleUniversal, /) -> None: ...

    @overload
    def visit(self, arg: RoleStaticAtomicState, /) -> None: ...

    @overload
    def visit(self, arg: RoleFluentAtomicState, /) -> None: ...

    @overload
    def visit(self, arg: RoleDerivedAtomicState, /) -> None: ...

    @overload
    def visit(self, arg: RoleStaticAtomicGoal, /) -> None: ...

    @overload
    def visit(self, arg: RoleFluentAtomicGoal, /) -> None: ...

    @overload
    def visit(self, arg: RoleDerivedAtomicGoal, /) -> None: ...

    @overload
    def visit(self, arg: RoleIntersection, /) -> None: ...

    @overload
    def visit(self, arg: RoleUnion, /) -> None: ...

    @overload
    def visit(self, arg: RoleComplement, /) -> None: ...

    @overload
    def visit(self, arg: RoleInverse, /) -> None: ...

    @overload
    def visit(self, arg: RoleComposition, /) -> None: ...

    @overload
    def visit(self, arg: RoleTransitiveClosure, /) -> None: ...

    @overload
    def visit(self, arg: RoleReflexiveTransitiveClosure, /) -> None: ...

    @overload
    def visit(self, arg: RoleRestriction, /) -> None: ...

    @overload
    def visit(self, arg: RoleIdentity, /) -> None: ...

    @overload
    def visit(self, arg: BooleanStaticAtomicState, /) -> None: ...

    @overload
    def visit(self, arg: BooleanFluentAtomicState, /) -> None: ...

    @overload
    def visit(self, arg: BooleanDerivedAtomicState, /) -> None: ...

    @overload
    def visit(self, arg: BooleanConceptNonempty, /) -> None: ...

    @overload
    def visit(self, arg: BooleanRoleNonempty, /) -> None: ...

    @overload
    def visit(self, arg: NumericalConceptCount, /) -> None: ...

    @overload
    def visit(self, arg: NumericalRoleCount, /) -> None: ...

    @overload
    def visit(self, arg: NumericalDistance, /) -> None: ...

class GeneratedSentencesContainer:
    def __init__(self) -> None: ...

class GeneratorVisitor:
    def __init__(self, arg0: IRefinementPruningFunction, arg1: GeneratedSentencesContainer, arg2: Repositories, arg3: int, /) -> None: ...

    def visit(self, arg: CNFGrammar, /) -> None: ...

class GrammarSpecificationEnum(enum.Enum):
    FRANCES_ET_AL_AAAI2021 = 0

class IRefinementPruningFunction:
    def __init__(self) -> None: ...

    @overload
    def should_prune(self, concept: Concept) -> bool: ...

    @overload
    def should_prune(self, role: Role) -> bool: ...

    @overload
    def should_prune(self, boolean: Boolean) -> bool: ...

    @overload
    def should_prune(self, numerical: Numerical) -> bool: ...

class Numerical:
    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def evaluate(self, evaluation_context: "mimir::languages::dl::EvaluationContext") -> "mimir::languages::dl::DenotationImpl<mimir::languages::dl::NumericalTag>": ...

    def accept(self, visitor: ConstructorVisitor) -> None: ...

    def get_index(self) -> int: ...

class NumericalConceptCount(Numerical):
    def get_constructor(self) -> Concept: ...

class NumericalDistance(Numerical):
    def get_left_concept(self) -> Concept: ...

    def get_role(self) -> Role: ...

    def get_right_concept(self) -> Concept: ...

class NumericalList:
    @overload
    def __init__(self) -> None:
        """Default constructor"""

    @overload
    def __init__(self, arg: NumericalList) -> None:
        """Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[Numerical], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __repr__(self) -> str: ...

    def __iter__(self) -> Iterator[Numerical]: ...

    @overload
    def __getitem__(self, arg: int, /) -> Numerical: ...

    @overload
    def __getitem__(self, arg: slice, /) -> NumericalList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: Numerical, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: Numerical, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> Numerical:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: NumericalList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: Numerical, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: NumericalList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def __eq__(self, arg: object, /) -> bool: ...

    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: Numerical, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: Numerical, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: Numerical, /) -> None:
        """Remove first occurrence of `arg`."""

class NumericalRoleCount(Numerical):
    def get_constructor(self) -> Role: ...

class Repositories:
    def __init__(self) -> None: ...

    def get_or_create_concept(self, sentence: str, domain: pymimir.advanced.formalism.Domain) -> Concept: ...

    def get_or_create_role(self, sentence: str, domain: pymimir.advanced.formalism.Domain) -> Role: ...

    def get_or_create_boolean(self, sentence: str, domain: pymimir.advanced.formalism.Domain) -> Boolean: ...

    def get_or_create_numerical(self, sentence: str, domain: pymimir.advanced.formalism.Domain) -> Numerical: ...

    def get_or_create_concept_bot(self) -> Concept: ...

    def get_or_create_concept_top(self) -> Concept: ...

    def get_or_create_concept_intersection(self, left_concept: Concept, right_concept: Concept) -> Concept: ...

    def get_or_create_concept_union(self, left_concept: Concept, right_concept: Concept) -> Concept: ...

    def get_or_create_concept_negation(self, concept_: Concept) -> Concept: ...

    def get_or_create_concept_value_restriction(self, role: Role, concept_: Concept) -> Concept: ...

    def get_or_create_concept_existential_quantification(self, role: Role, concept_: Concept) -> Concept: ...

    def get_or_create_concept_role_value_map_containment(self, left_role: Role, right_role: Role) -> Concept: ...

    def get_or_create_concept_role_value_map_equality(self, left_role: Role, right_role: Role) -> Concept: ...

    def get_or_create_concept_nominal(self, object: pymimir.advanced.formalism.Object) -> Concept: ...

    def get_or_create_role_universal(self) -> Role: ...

    def get_or_create_role_intersection(self, left_role: Role, right_role: Role) -> Role: ...

    def get_or_create_role_union(self, left_role: Role, right_role: Role) -> Role: ...

    def get_or_create_role_complement(self, role: Role) -> Role: ...

    def get_or_create_role_inverse(self, role: Role) -> Role: ...

    def get_or_create_role_composition(self, left_role: Role, right_role: Role) -> Role: ...

    def get_or_create_role_transitive_closure(self, role: Role) -> Role: ...

    def get_or_create_role_reflexive_transitive_closure(self, role: Role) -> Role: ...

    def get_or_create_role_restriction(self, role: Role, concept_: Concept) -> Role: ...

    def get_or_create_role_identity(self, concept_: Concept) -> Role: ...

    def get_or_create_concept_atomic_state_static(self, predicate: pymimir.advanced.formalism.StaticPredicate) -> Concept: ...

    def get_or_create_concept_atomic_state_fluent(self, predicate: pymimir.advanced.formalism.FluentPredicate) -> Concept: ...

    def get_or_create_concept_atomic_state_derived(self, predicate: pymimir.advanced.formalism.DerivedPredicate) -> Concept: ...

    def get_or_create_concept_atomic_goal_static(self, predicate: pymimir.advanced.formalism.StaticPredicate, polarity: bool) -> Concept: ...

    def get_or_create_concept_atomic_goal_fluent(self, predicate: pymimir.advanced.formalism.FluentPredicate, polarity: bool) -> Concept: ...

    def get_or_create_concept_atomic_goal_derived(self, predicate: pymimir.advanced.formalism.DerivedPredicate, polarity: bool) -> Concept: ...

    def get_or_create_role_atomic_state_static(self, predicate: pymimir.advanced.formalism.StaticPredicate) -> Role: ...

    def get_or_create_role_atomic_state_fluent(self, predicate: pymimir.advanced.formalism.FluentPredicate) -> Role: ...

    def get_or_create_role_atomic_state_derived(self, predicate: pymimir.advanced.formalism.DerivedPredicate) -> Role: ...

    def get_or_create_role_atomic_goal_static(self, predicate: pymimir.advanced.formalism.StaticPredicate, polarity: bool) -> Role: ...

    def get_or_create_role_atomic_goal_fluent(self, predicate: pymimir.advanced.formalism.FluentPredicate, polarity: bool) -> Role: ...

    def get_or_create_role_atomic_goal_derived(self, predicate: pymimir.advanced.formalism.DerivedPredicate, polarity: bool) -> Role: ...

    def get_or_create_boolean_atomic_state_static(self, predicate: pymimir.advanced.formalism.StaticPredicate) -> Boolean: ...

    def get_or_create_boolean_atomic_state_fluent(self, predicate: pymimir.advanced.formalism.FluentPredicate) -> Boolean: ...

    def get_or_create_boolean_atomic_state_derived(self, predicate: pymimir.advanced.formalism.DerivedPredicate) -> Boolean: ...

    def get_or_create_boolean_nonempty_concept(self, constructor: Concept) -> Boolean: ...

    def get_or_create_boolean_nonempty_role(self, constructor: Role) -> Boolean: ...

    def get_or_create_numerical_count_concept(self, constructor: Concept) -> Numerical: ...

    def get_or_create_numerical_count_role(self, constructor: Role) -> Numerical: ...

    def get_or_create_numerical_distance(self, left_concept: Concept, role: Role, right_concept: Concept) -> Numerical: ...

class Role:
    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def evaluate(self, evaluation_context: "mimir::languages::dl::EvaluationContext") -> "mimir::languages::dl::DenotationImpl<mimir::languages::dl::RoleTag>": ...

    def accept(self, visitor: ConstructorVisitor) -> None: ...

    def get_index(self) -> int: ...

class RoleComplement(Role):
    def get_role(self) -> Role: ...

class RoleComposition(Role):
    def get_left_role(self) -> Role: ...

    def get_right_role(self) -> Role: ...

class RoleDerivedAtomicGoal(Role):
    def get_predicate(self) -> pymimir.advanced.formalism.DerivedPredicate: ...

    def get_polarity(self) -> bool: ...

class RoleDerivedAtomicState(Role):
    def get_predicate(self) -> pymimir.advanced.formalism.DerivedPredicate: ...

class RoleFluentAtomicGoal(Role):
    def get_predicate(self) -> pymimir.advanced.formalism.FluentPredicate: ...

    def get_polarity(self) -> bool: ...

class RoleFluentAtomicState(Role):
    def get_predicate(self) -> pymimir.advanced.formalism.FluentPredicate: ...

class RoleIdentity(Role):
    def get_concept(self) -> Concept: ...

class RoleIntersection(Role):
    def get_left_role(self) -> Role: ...

    def get_right_role(self) -> Role: ...

class RoleInverse(Role):
    def get_role(self) -> Role: ...

class RoleList:
    @overload
    def __init__(self) -> None:
        """Default constructor"""

    @overload
    def __init__(self, arg: RoleList) -> None:
        """Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[Role], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __repr__(self) -> str: ...

    def __iter__(self) -> Iterator[Role]: ...

    @overload
    def __getitem__(self, arg: int, /) -> Role: ...

    @overload
    def __getitem__(self, arg: slice, /) -> RoleList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: Role, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: Role, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> Role:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: RoleList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: Role, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: RoleList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def __eq__(self, arg: object, /) -> bool: ...

    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: Role, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: Role, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: Role, /) -> None:
        """Remove first occurrence of `arg`."""

class RoleReflexiveTransitiveClosure(Role):
    def get_role(self) -> Role: ...

class RoleRestriction(Role):
    def get_role(self) -> Role: ...

    def get_concept(self) -> Concept: ...

class RoleStaticAtomicGoal(Role):
    def get_predicate(self) -> pymimir.advanced.formalism.StaticPredicate: ...

    def get_polarity(self) -> bool: ...

class RoleStaticAtomicState(Role):
    def get_predicate(self) -> pymimir.advanced.formalism.StaticPredicate: ...

class RoleTransitiveClosure(Role):
    def get_role(self) -> Role: ...

class RoleUnion(Role):
    def get_left_role(self) -> Role: ...

    def get_right_role(self) -> Role: ...

class RoleUniversal(Role):
    pass

class StateListRefinementPruningFunction(IRefinementPruningFunction):
    @overload
    def __init__(self, arg: pymimir.advanced.datasets.GeneralizedStateSpace, /) -> None: ...

    @overload
    def __init__(self, arg0: pymimir.advanced.datasets.GeneralizedStateSpace, arg1: pymimir.advanced.datasets.BidirectionalStaticClassGraph, /) -> None: ...

    @overload
    def __init__(self, arg: Mapping[pymimir.advanced.formalism.Problem, pymimir.advanced.search.StateList], /) -> None: ...
