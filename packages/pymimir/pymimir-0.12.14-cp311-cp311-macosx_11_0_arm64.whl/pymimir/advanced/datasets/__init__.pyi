from collections.abc import Iterator, Sequence
from typing import overload

import pymimir


class BidirectionalStaticClassGraph:
    @overload
    def __init__(self, arg: StaticClassGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticClassGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> list[ClassEdge]: ...

    def get_edge(self, arg: int, /) -> ClassVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class BidirectionalStaticProblemGraph:
    @overload
    def __init__(self, arg: StaticProblemGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticProblemGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> list[ProblemEdge]: ...

    def get_edge(self, arg: int, /) -> ProblemVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class BidirectionalStaticTupleGraph:
    @overload
    def __init__(self, arg: StaticTupleGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticTupleGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[TupleGraphVertex]: ...

    def get_vertex(self, vertex_index: int) -> TupleGraphVertex: ...

    def get_edges(self) -> list[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_edge(self, arg: int, /) -> TupleGraphVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class ClassEdge:
    def get_index(self) -> int: ...

    def get_source(self) -> int: ...

    def get_target(self) -> int: ...

    def get_property_0(self) -> int: ...

    def get_property_1(self) -> int: ...

class ClassVertex:
    def get_index(self) -> int: ...

    def get_property_0(self) -> int: ...

    def get_property_1(self) -> int: ...

class ForwardStaticClassGraph:
    @overload
    def __init__(self, arg: StaticClassGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticClassGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> list[ClassEdge]: ...

    def get_edge(self, arg: int, /) -> ClassVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class ForwardStaticProblemGraph:
    @overload
    def __init__(self, arg: StaticProblemGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticProblemGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> list[ProblemEdge]: ...

    def get_edge(self, arg: int, /) -> ProblemVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class ForwardStaticTupleGraph:
    @overload
    def __init__(self, arg: StaticTupleGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableStaticTupleGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[TupleGraphVertex]: ...

    def get_vertex(self, vertex_index: int) -> TupleGraphVertex: ...

    def get_edges(self) -> list[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_edge(self, arg: int, /) -> TupleGraphVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class GeneralizedStateSpace:
    def __str__(self) -> str: ...

    @staticmethod
    def create(state_spaces: Sequence[tuple[StateSpace, "mimir::datasets::CertificateMaps" | None]], options: GeneralizedStateSpaceOptions = ...) -> tuple[GeneralizedStateSpace, list["mimir::datasets::CertificateMaps"] | None]: ...

    def get_state_spaces(self) -> list[StateSpace]: ...

    def get_graph(self) -> BidirectionalStaticClassGraph: ...

    def get_initial_vertices(self) -> set[int]: ...

    def get_goal_vertices(self) -> set[int]: ...

    def get_unsolvable_vertices(self) -> set[int]: ...

    @overload
    def get_state_space(self, arg: ClassVertex, /) -> StateSpace: ...

    @overload
    def get_state_space(self, arg: ClassEdge, /) -> StateSpace: ...

    def get_problem_vertex(self, arg: ClassVertex, /) -> ProblemVertex: ...

    def get_problem_edge(self, arg: ClassEdge, /) -> ProblemEdge: ...

    def get_class_vertex(self, arg: ProblemVertex, /) -> ClassVertex: ...

    def get_class_edge(self, arg: ProblemEdge, /) -> ClassEdge: ...

    def create_induced_subgraph_from_class_vertex_indices(self, arg: Sequence[int], /) -> BidirectionalStaticClassGraph: ...

    def create_induced_subgraph_from_problem_indices(self, arg: Sequence[int], /) -> BidirectionalStaticClassGraph: ...

class GeneralizedStateSpaceOptions:
    def __init__(self) -> None: ...

    @property
    def symmetry_pruning(self) -> bool: ...

    @symmetry_pruning.setter
    def symmetry_pruning(self, arg: bool, /) -> None: ...

class ImmutableStaticClassGraph:
    def __init__(self, arg: StaticClassGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> list[ClassEdge]: ...

    def get_edge(self, arg: int, /) -> ClassEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class ImmutableStaticProblemGraph:
    def __init__(self, arg: StaticProblemGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> list[ProblemEdge]: ...

    def get_edge(self, arg: int, /) -> ProblemEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class ImmutableStaticTupleGraph:
    def __init__(self, arg: StaticTupleGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[TupleGraphVertex]: ...

    def get_vertex(self, vertex_index: int) -> TupleGraphVertex: ...

    def get_edges(self) -> list[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_edge(self, arg: int, /) -> pymimir.advanced.graphs.EmptyEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class KnowledgeBase:
    @staticmethod
    def create(contexts: pymimir.advanced.search.GeneralizedSearchContext, options: KnowledgeBaseOptions = ...) -> KnowledgeBase: ...

    def get_generalized_state_space(self) -> GeneralizedStateSpace | None: ...

    def get_tuple_graphs(self) -> list[list[TupleGraph]] | None: ...

class KnowledgeBaseOptions:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, state_space_options: StateSpaceOptions, generalized_state_space_options: GeneralizedStateSpaceOptions, tuple_graph_options: TupleGraphOptions | None = None) -> None: ...

    @property
    def state_space_options(self) -> StateSpaceOptions: ...

    @state_space_options.setter
    def state_space_options(self, arg: StateSpaceOptions, /) -> None: ...

    @property
    def generalized_state_space_options(self) -> GeneralizedStateSpaceOptions | None: ...

    @generalized_state_space_options.setter
    def generalized_state_space_options(self, arg: GeneralizedStateSpaceOptions, /) -> None: ...

    @property
    def tuple_graph_options(self) -> TupleGraphOptions | None: ...

    @tuple_graph_options.setter
    def tuple_graph_options(self, arg: TupleGraphOptions, /) -> None: ...

class ProblemEdge:
    def get_index(self) -> int: ...

    def get_source(self) -> int: ...

    def get_target(self) -> int: ...

    def get_property_0(self) -> pymimir.advanced.formalism.GroundAction: ...

    def get_property_1(self) -> pymimir.advanced.formalism.Problem: ...

    def get_property_2(self) -> float: ...

class ProblemVertex:
    def get_index(self) -> int: ...

    def get_property_0(self) -> pymimir.advanced.search.State: ...

    def get_property_1(self) -> pymimir.advanced.formalism.Problem: ...

    def get_property_2(self) -> int: ...

    def get_property_3(self) -> float: ...

    def get_property_4(self) -> bool: ...

    def get_property_5(self) -> bool: ...

    def get_property_6(self) -> bool: ...

    def get_property_7(self) -> bool: ...

class StateSpace:
    def __str__(self) -> str: ...

    @overload
    @staticmethod
    def create(context: pymimir.advanced.search.SearchContext, options: StateSpaceOptions = ...) -> tuple[StateSpace, "mimir::datasets::CertificateMaps" | None] | None: ...

    @overload
    @staticmethod
    def create(contexts: pymimir.advanced.search.GeneralizedSearchContext, options: StateSpaceOptions = ...) -> list[tuple[StateSpace, "mimir::datasets::CertificateMaps" | None]]: ...

    def get_search_context(self) -> pymimir.advanced.search.SearchContext: ...

    def get_graph(self) -> BidirectionalStaticProblemGraph: ...

    def get_initial_vertex(self) -> int: ...

    def get_goal_vertices(self) -> set[int]: ...

    def get_unsolvable_vertices(self) -> set[int]: ...

class StateSpaceOptions:
    def __init__(self) -> None: ...

    @property
    def sort_ascending_by_num_states(self) -> bool: ...

    @sort_ascending_by_num_states.setter
    def sort_ascending_by_num_states(self, arg: bool, /) -> None: ...

    @property
    def symmetry_pruning(self) -> bool: ...

    @symmetry_pruning.setter
    def symmetry_pruning(self, arg: bool, /) -> None: ...

    @property
    def remove_if_unsolvable(self) -> bool: ...

    @remove_if_unsolvable.setter
    def remove_if_unsolvable(self, arg: bool, /) -> None: ...

    @property
    def max_num_states(self) -> int: ...

    @max_num_states.setter
    def max_num_states(self, arg: int, /) -> None: ...

    @property
    def timeout_ms(self) -> int: ...

    @timeout_ms.setter
    def timeout_ms(self, arg: int, /) -> None: ...

class StaticClassGraph:
    def __init__(self) -> None: ...

    def clear(self) -> None: ...

    @overload
    def add_vertex(self, *args) -> int: ...

    @overload
    def add_vertex(self, arg: ClassVertex, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, /, *args) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: ClassEdge, /) -> int: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> list[ClassEdge]: ...

    def get_edge(self, arg: int, /) -> ClassVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class StaticProblemGraph:
    def __init__(self) -> None: ...

    def clear(self) -> None: ...

    @overload
    def add_vertex(self, *args) -> int: ...

    @overload
    def add_vertex(self, arg: ProblemVertex, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, /, *args) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: ProblemEdge, /) -> int: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> list[ProblemEdge]: ...

    def get_edge(self, arg: int, /) -> ProblemVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class StaticTupleGraph:
    def __init__(self) -> None: ...

    def clear(self) -> None: ...

    @overload
    def add_vertex(self, *args) -> int: ...

    @overload
    def add_vertex(self, arg: TupleGraphVertex, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, /, *args) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: pymimir.advanced.graphs.EmptyEdge, /) -> int: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[TupleGraphVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[TupleGraphVertex]: ...

    def get_vertex(self, vertex_index: int) -> TupleGraphVertex: ...

    def get_edges(self) -> list[pymimir.advanced.graphs.EmptyEdge]: ...

    def get_edge(self, arg: int, /) -> TupleGraphVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<int, std::__1::allocator<int>>>": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::__1::tuple<std::__1::vector<unsigned int, std::__1::allocator<unsigned int>>, std::__1::vector<double, std::__1::allocator<double>>>": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class TupleGraph:
    def __str__(self) -> str: ...

    def get_state_space(self) -> StateSpace: ...

    def get_graph(self) -> BidirectionalStaticTupleGraph: ...

    def get_tuple_vertex_indices_grouped_by_distance(self) -> list[list[int]]: ...

    def get_problem_vertex_indices_grouped_by_distance(self) -> list[list[int]]: ...

class TupleGraphOptions:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, width: int, enable_dominance_pruning: bool) -> None: ...

    @property
    def width(self) -> int: ...

    @width.setter
    def width(self, arg: int, /) -> None: ...

    @property
    def enable_dominance_pruning(self) -> bool: ...

    @enable_dominance_pruning.setter
    def enable_dominance_pruning(self, arg: bool, /) -> None: ...

class TupleGraphVertex:
    def get_index(self) -> int: ...

    def get_property_0(self) -> list[int]: ...

    def get_property_1(self) -> list[int]: ...
