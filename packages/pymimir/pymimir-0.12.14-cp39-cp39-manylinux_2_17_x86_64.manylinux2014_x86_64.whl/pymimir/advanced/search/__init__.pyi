from collections.abc import Iterable, Iterator, Sequence
import enum
from typing import Optional, overload

import pymimir


class AStarStatistics:
    def __init__(self) -> None: ...

    def get_num_generated(self) -> int: ...

    def get_num_expanded(self) -> int: ...

    def get_num_deadends(self) -> int: ...

    def get_num_pruned(self) -> int: ...

    def get_num_generated_until_f_value(self) -> dict[float, int]: ...

    def get_num_expanded_until_f_value(self) -> dict[float, int]: ...

    def get_num_deadends_until_f_value(self) -> dict[float, int]: ...

    def get_num_pruned_until_f_value(self) -> dict[float, int]: ...

class ActionSatisficingBindingGenerator:
    def __init__(self, action: pymimir.advanced.formalism.Action, problem: pymimir.advanced.formalism.Problem) -> None: ...

    def generate_ground_conjunctions(self, state: State, max_num_groundings: int) -> list[tuple[pymimir.advanced.formalism.ObjectList, "std::tuple<std::vector<mimir::formalism::GroundLiteralImpl<mimir::formalism::StaticTag> const*, std::allocator<mimir::formalism::GroundLiteralImpl<mimir::formalism::StaticTag> const*> >, std::vector<mimir::formalism::GroundLiteralImpl<mimir::formalism::FluentTag> const*, std::allocator<mimir::formalism::GroundLiteralImpl<mimir::formalism::FluentTag> const*> >, std::vector<mimir::formalism::GroundLiteralImpl<mimir::formalism::DerivedTag> const*, std::allocator<mimir::formalism::GroundLiteralImpl<mimir::formalism::DerivedTag> const*> > >"]]: ...

class ArityKNoveltyPruningStrategy(IPruningStrategy):
    def __init__(self, arg0: int, arg1: int, /) -> None: ...

    @staticmethod
    def create(arity: int, num_atoms: int) -> ArityKNoveltyPruningStrategy: ...

class ArityZeroNoveltyPruningStrategy(IPruningStrategy):
    def __init__(self, arg: State, /) -> None: ...

    @staticmethod
    def create(initial_state: State) -> ArityZeroNoveltyPruningStrategy: ...

class AxiomSatisficingBindingGenerator:
    def __init__(self, axiom: pymimir.advanced.formalism.Axiom, problem: pymimir.advanced.formalism.Problem) -> None: ...

    def generate_ground_conjunctions(self, state: State, max_num_groundings: int) -> list[tuple[pymimir.advanced.formalism.ObjectList, "std::tuple<std::vector<mimir::formalism::GroundLiteralImpl<mimir::formalism::StaticTag> const*, std::allocator<mimir::formalism::GroundLiteralImpl<mimir::formalism::StaticTag> const*> >, std::vector<mimir::formalism::GroundLiteralImpl<mimir::formalism::FluentTag> const*, std::allocator<mimir::formalism::GroundLiteralImpl<mimir::formalism::FluentTag> const*> >, std::vector<mimir::formalism::GroundLiteralImpl<mimir::formalism::DerivedTag> const*, std::allocator<mimir::formalism::GroundLiteralImpl<mimir::formalism::DerivedTag> const*> > >"]]: ...

class BlindHeuristic(IHeuristic):
    def __init__(self, arg: pymimir.advanced.formalism.Problem, /) -> None: ...

class BrFSStatistics:
    def __init__(self) -> None: ...

    def get_num_generated(self) -> int: ...

    def get_num_expanded(self) -> int: ...

    def get_num_deadends(self) -> int: ...

    def get_num_pruned(self) -> int: ...

    def get_num_generated_until_g_value(self) -> list[int]: ...

    def get_num_expanded_until_g_value(self) -> list[int]: ...

    def get_num_deadends_until_g_value(self) -> list[int]: ...

    def get_num_pruned_until_g_value(self) -> list[int]: ...

CLOSED: SearchNodeStatus = SearchNodeStatus.CLOSED

class ConjunctiveConditionSatisficingBindingGenerator:
    def __init__(self, conjunctive_condition: pymimir.advanced.formalism.ConjunctiveCondition, problem: pymimir.advanced.formalism.Problem) -> None: ...

    def generate_ground_conjunctions(self, state: State, max_num_groundings: int) -> list[tuple[pymimir.advanced.formalism.ObjectList, "std::tuple<std::vector<mimir::formalism::GroundLiteralImpl<mimir::formalism::StaticTag> const*, std::allocator<mimir::formalism::GroundLiteralImpl<mimir::formalism::StaticTag> const*> >, std::vector<mimir::formalism::GroundLiteralImpl<mimir::formalism::FluentTag> const*, std::allocator<mimir::formalism::GroundLiteralImpl<mimir::formalism::FluentTag> const*> >, std::vector<mimir::formalism::GroundLiteralImpl<mimir::formalism::DerivedTag> const*, std::allocator<mimir::formalism::GroundLiteralImpl<mimir::formalism::DerivedTag> const*> > >"]]: ...

DEAD_END: SearchNodeStatus = SearchNodeStatus.DEAD_END

class DebugAStarEventHandler(IAStarEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DebugBrFSEventHandler(IBrFSEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DebugGroundedApplicableActionGeneratorEventHandler(IGroundedApplicableActionGeneratorEventHandler):
    def __init__(self) -> None: ...

class DebugGroundedAxiomEvaluatorEventHandler(IGroundedAxiomEvaluatorEventHandler):
    def __init__(self) -> None: ...

class DebugLiftedApplicableActionGeneratorEventHandler(ILiftedApplicableActionGeneratorEventHandler):
    def __init__(self) -> None: ...

class DebugLiftedAxiomEvaluatorEventHandler(ILiftedAxiomEvaluatorEventHandler):
    def __init__(self) -> None: ...

class DefaultAStarEventHandler(IAStarEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DefaultBrFSEventHandler(IBrFSEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DefaultGroundedApplicableActionGeneratorEventHandler(IGroundedApplicableActionGeneratorEventHandler):
    def __init__(self) -> None: ...

class DefaultGroundedAxiomEvaluatorEventHandler(IGroundedAxiomEvaluatorEventHandler):
    def __init__(self) -> None: ...

class DefaultIWEventHandler(IIWEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DefaultLiftedApplicableActionGeneratorEventHandler(ILiftedApplicableActionGeneratorEventHandler):
    def __init__(self) -> None: ...

class DefaultLiftedAxiomEvaluatorEventHandler(ILiftedAxiomEvaluatorEventHandler):
    def __init__(self) -> None: ...

class DefaultSIWEventHandler(ISIWEventHandler):
    def __init__(self, problem: pymimir.advanced.formalism.Problem, quiet: bool = True) -> None: ...

class DeleteRelaxedProblemExplorator:
    def __init__(self, problem: pymimir.advanced.formalism.Problem) -> None: ...

    def create_grounded_axiom_evaluator(self, match_tree_options: MatchTreeOptions = ..., axiom_evaluator_event_handler: Optional[IGroundedAxiomEvaluatorEventHandler] = None) -> GroundedAxiomEvaluator: ...

    def create_grounded_applicable_action_generator(self, match_tree_options: MatchTreeOptions = ..., axiom_evaluator_event_handler: Optional[IGroundedApplicableActionGeneratorEventHandler] = None) -> GroundedApplicableActionGenerator: ...

class DuplicatePruningStrategy(IPruningStrategy):
    def __init__(self) -> None: ...

    @staticmethod
    def create() -> DuplicatePruningStrategy: ...

EXHAUSTED: SearchStatus = SearchStatus.EXHAUSTED

FAILED: SearchStatus = SearchStatus.FAILED

GROUNDED: SearchMode = SearchMode.GROUNDED

class GeneralizedSearchContext:
    @overload
    @staticmethod
    def create(domain_filepath: str, problem_filepaths: Sequence[str], options: SearchContextOptions = ...) -> GeneralizedSearchContext: ...

    @overload
    @staticmethod
    def create(domain_filepath: str, problems_directory: str, options: SearchContextOptions = ...) -> GeneralizedSearchContext: ...

    @overload
    @staticmethod
    def create(generalized_problem: pymimir.advanced.formalism.GeneralizedProblem, options: SearchContextOptions = ...) -> GeneralizedSearchContext: ...

    @overload
    @staticmethod
    def create(generalized_problem: pymimir.advanced.formalism.GeneralizedProblem, search_contexts: Sequence[SearchContext]) -> GeneralizedSearchContext: ...

    def get_generalized_problem(self) -> pymimir.advanced.formalism.GeneralizedProblem: ...

    def get_search_contexts(self) -> list[SearchContext]: ...

class GroundedApplicableActionGenerator(IApplicableActionGenerator):
    pass

class GroundedAxiomEvaluator(IAxiomEvaluator):
    pass

class IAStarEventHandler:
    def __init__(self) -> None: ...

    def on_expand_state(self, arg: State, /) -> None: ...

    def on_expand_goal_state(self, arg: State, /) -> None: ...

    def on_generate_state(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_generate_state_relaxed(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_generate_state_not_relaxed(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_close_state(self, arg: State, /) -> None: ...

    def on_finish_f_layer(self, arg: float, /) -> None: ...

    def on_prune_state(self, arg: State, /) -> None: ...

    def on_start_search(self, arg: State, /) -> None: ...

    def on_end_search(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, /) -> None: ...

    def on_solved(self, arg: Plan, /) -> None: ...

    def on_unsolvable(self) -> None: ...

    def on_exhausted(self) -> None: ...

    def get_statistics(self) -> AStarStatistics: ...

class IApplicableActionGenerator:
    def get_problem(self) -> pymimir.advanced.formalism.Problem: ...

    def generate_applicable_actions(self, state: State) -> pymimir.advanced.formalism.GroundActionList: ...

class IAxiomEvaluator:
    def get_problem(self) -> pymimir.advanced.formalism.Problem: ...

class IBrFSEventHandler:
    def __init__(self) -> None: ...

    def on_expand_state(self, arg: State, /) -> None: ...

    def on_expand_goal_state(self, arg: State, /) -> None: ...

    def on_generate_state(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_generate_state_in_search_tree(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_generate_state_not_in_search_tree(self, arg0: State, arg1: pymimir.advanced.formalism.GroundAction, arg2: float, arg3: State, /) -> None: ...

    def on_finish_g_layer(self, arg: int, /) -> None: ...

    def on_start_search(self, arg: State, /) -> None: ...

    def on_end_search(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, /) -> None: ...

    def on_solved(self, arg: Plan, /) -> None: ...

    def on_unsolvable(self) -> None: ...

    def on_exhausted(self) -> None: ...

    def get_statistics(self) -> BrFSStatistics: ...

class IGoalStrategy:
    def __init__(self) -> None: ...

    def test_static_goal(self) -> bool: ...

    def test_dynamic_goal(self, state: State) -> bool: ...

class IGroundedApplicableActionGeneratorEventHandler:
    pass

class IGroundedAxiomEvaluatorEventHandler:
    pass

class IHeuristic:
    def __init__(self) -> None: ...

    def compute_heuristic(self, arg0: State, arg1: bool, /) -> float: ...

class IIWEventHandler:
    def get_statistics(self) -> IWStatistics: ...

class ILiftedApplicableActionGeneratorEventHandler:
    pass

class ILiftedAxiomEvaluatorEventHandler:
    pass

IN_PROGRESS: SearchStatus = SearchStatus.IN_PROGRESS

class IPruningStrategy:
    def __init__(self) -> None: ...

    def test_prune_initial_state(self, arg: State, /) -> bool: ...

    def test_prune_successor_state(self, arg0: State, arg1: State, arg2: bool, /) -> bool: ...

class ISIWEventHandler:
    def get_statistics(self) -> SIWStatistics: ...

class IWStatistics:
    def __init__(self) -> None: ...

    def get_effective_width(self) -> int: ...

    def get_brfs_statistics_by_arity(self) -> list[BrFSStatistics]: ...

LIFTED: SearchMode = SearchMode.LIFTED

class LiftedApplicableActionGenerator(IApplicableActionGenerator):
    @overload
    def __init__(self, problem: pymimir.advanced.formalism.Problem) -> None: ...

    @overload
    def __init__(self, problem: pymimir.advanced.formalism.Problem, event_handler: ILiftedApplicableActionGeneratorEventHandler) -> None: ...

class LiftedAxiomEvaluator(IAxiomEvaluator):
    @overload
    def __init__(self, problem: pymimir.advanced.formalism.Problem) -> None: ...

    @overload
    def __init__(self, problem: pymimir.advanced.formalism.Problem, event_handler: ILiftedAxiomEvaluatorEventHandler) -> None: ...

class MatchTreeOptions:
    def __init__(self) -> None: ...

    @property
    def enable_dump_dot_file(self) -> bool: ...

    @enable_dump_dot_file.setter
    def enable_dump_dot_file(self, arg: bool, /) -> None: ...

    @property
    def output_dot_file(self) -> "std::filesystem::path": ...

    @output_dot_file.setter
    def output_dot_file(self, arg: "std::filesystem::path", /) -> None: ...

    @property
    def max_num_nodes(self) -> int: ...

    @max_num_nodes.setter
    def max_num_nodes(self, arg: int, /) -> None: ...

    @property
    def split_strategy(self) -> "mimir::search::match_tree::SplitStrategyEnum": ...

    @split_strategy.setter
    def split_strategy(self, arg: "mimir::search::match_tree::SplitStrategyEnum", /) -> None: ...

    @property
    def split_metric(self) -> "mimir::search::match_tree::SplitMetricEnum": ...

    @split_metric.setter
    def split_metric(self, arg: "mimir::search::match_tree::SplitMetricEnum", /) -> None: ...

    @property
    def optimization_direction(self) -> "mimir::search::match_tree::OptimizationDirectionEnum": ...

    @optimization_direction.setter
    def optimization_direction(self, arg: "mimir::search::match_tree::OptimizationDirectionEnum", /) -> None: ...

NEW: SearchNodeStatus = SearchNodeStatus.NEW

class NoPruningStrategy(IPruningStrategy):
    def __init__(self) -> None: ...

    @staticmethod
    def create() -> NoPruningStrategy: ...

OPEN: SearchNodeStatus = SearchNodeStatus.OPEN

OUT_OF_MEMORY: SearchStatus = SearchStatus.OUT_OF_MEMORY

OUT_OF_TIME: SearchStatus = SearchStatus.OUT_OF_TIME

class Plan:
    def __len__(self) -> int: ...

    def get_actions(self) -> pymimir.advanced.formalism.GroundActionList: ...

    def get_cost(self) -> float: ...

class ProblemGoalStrategy(IGoalStrategy):
    def __init__(self, arg: pymimir.advanced.formalism.Problem, /) -> None: ...

    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem) -> ProblemGoalStrategy: ...

class SIWStatistics:
    def __init__(self) -> None: ...

    def get_maximum_effective_width(self) -> int: ...

    def get_average_effective_width(self) -> float: ...

    def get_iw_statistics_by_subproblem(self) -> list[IWStatistics]: ...

SOLVED: SearchStatus = SearchStatus.SOLVED

class SearchContext:
    @overload
    @staticmethod
    def create(domain_filepath: str, problem_filepath: str, options: SearchContextOptions = ...) -> SearchContext: ...

    @overload
    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem, options: SearchContextOptions = ...) -> SearchContext: ...

    @overload
    @staticmethod
    def create(problem: pymimir.advanced.formalism.Problem, applicable_action_generator: IApplicableActionGenerator, state_repository: StateRepository) -> SearchContext: ...

    def get_problem(self) -> pymimir.advanced.formalism.Problem: ...

    def get_applicable_action_generator(self) -> IApplicableActionGenerator: ...

    def get_state_repository(self) -> StateRepository: ...

class SearchContextOptions:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, mode: SearchMode) -> None: ...

    @property
    def mode(self) -> SearchMode: ...

    @mode.setter
    def mode(self, arg: SearchMode, /) -> None: ...

class SearchMode(enum.Enum):
    GROUNDED = 0

    LIFTED = 1

class SearchNodeStatus(enum.Enum):
    NEW = 0

    OPEN = 1

    CLOSED = 2

    DEAD_END = 3

class SearchResult:
    def __init__(self) -> None: ...

    @property
    def status(self) -> SearchStatus: ...

    @status.setter
    def status(self, arg: SearchStatus, /) -> None: ...

    @property
    def plan(self) -> Optional[Plan]: ...

    @plan.setter
    def plan(self, arg: Plan, /) -> None: ...

    @property
    def goal_state(self) -> Optional[State]: ...

    @goal_state.setter
    def goal_state(self, arg: State, /) -> None: ...

class SearchStatus(enum.Enum):
    IN_PROGRESS = 0

    OUT_OF_TIME = 1

    OUT_OF_MEMORY = 2

    FAILED = 3

    EXHAUSTED = 4

    SOLVED = 5

    UNSOLVABLE = 6

class State:
    def __hash__(self) -> int: ...

    def __eq__(self, arg: State, /) -> bool: ...

    def get_fluent_atoms(self) -> Iterator[int]: ...

    def get_derived_atoms(self) -> Iterator[int]: ...

    def to_string(self, problem: pymimir.advanced.formalism.Problem) -> str: ...

    def get_index(self) -> int: ...

class StateList:
    @overload
    def __init__(self) -> None:
        """Default constructor"""

    @overload
    def __init__(self, arg: StateList) -> None:
        """Copy constructor"""

    @overload
    def __init__(self, arg: Iterable[State], /) -> None:
        """Construct from an iterable object"""

    def __len__(self) -> int: ...

    def __bool__(self) -> bool:
        """Check whether the vector is nonempty"""

    def __repr__(self) -> str: ...

    def __iter__(self) -> Iterator[State]: ...

    @overload
    def __getitem__(self, arg: int, /) -> State: ...

    @overload
    def __getitem__(self, arg: slice, /) -> StateList: ...

    def clear(self) -> None:
        """Remove all items from list."""

    def append(self, arg: State, /) -> None:
        """Append `arg` to the end of the list."""

    def insert(self, arg0: int, arg1: State, /) -> None:
        """Insert object `arg1` before index `arg0`."""

    def pop(self, index: int = -1) -> State:
        """Remove and return item at `index` (default last)."""

    def extend(self, arg: StateList, /) -> None:
        """Extend `self` by appending elements from `arg`."""

    @overload
    def __setitem__(self, arg0: int, arg1: State, /) -> None: ...

    @overload
    def __setitem__(self, arg0: slice, arg1: StateList, /) -> None: ...

    @overload
    def __delitem__(self, arg: int, /) -> None: ...

    @overload
    def __delitem__(self, arg: slice, /) -> None: ...

    def __eq__(self, arg: object, /) -> bool: ...

    def __ne__(self, arg: object, /) -> bool: ...

    @overload
    def __contains__(self, arg: State, /) -> bool: ...

    @overload
    def __contains__(self, arg: object, /) -> bool: ...

    def count(self, arg: State, /) -> int:
        """Return number of occurrences of `arg`."""

    def remove(self, arg: State, /) -> None:
        """Remove first occurrence of `arg`."""

class StatePairTupleIndexGenerator:
    def __init__(self, tuple_index_mapper: TupleIndexMapper) -> None: ...

    def __iter__(self, arg0: State, arg1: State, /) -> Iterator[int]: ...

class StateRepository:
    def __init__(self, axiom_evaluator: IAxiomEvaluator) -> None: ...

    def get_or_create_initial_state(self) -> tuple[State, float]: ...

    def get_or_create_state(self, atoms: pymimir.advanced.formalism.FluentGroundAtomList, numeric_variables: pymimir.advanced.common.FlatDoubleList) -> tuple[State, float]: ...

    def get_or_create_successor_state(self, state: State, action: pymimir.advanced.formalism.GroundAction, state_metric_value: float) -> tuple[State, float]: ...

    def get_state_count(self) -> int: ...

    def get_reached_fluent_ground_atoms_bitset(self) -> pymimir.advanced.common.FlatBitset: ...

    def get_reached_derived_ground_atoms_bitset(self) -> pymimir.advanced.common.FlatBitset: ...

class StateTupleIndexGenerator:
    def __init__(self, tuple_index_mapper: TupleIndexMapper) -> None: ...

    def __iter__(self, arg: State, /) -> Iterator[int]: ...

class TupleIndexMapper:
    def __init__(self, arity: int, num_atoms: int) -> None: ...

    def to_tuple_index(self, atom_indices: Sequence[int]) -> int: ...

    def to_atom_indices(self, tuple_index: int) -> list[int]: ...

    def initialize(self, arity: int, num_atoms: int) -> None: ...

    def tuple_index_to_string(self, tuple_index: int) -> str: ...

    def get_num_atoms(self) -> int: ...

    def get_arity(self) -> int: ...

    def get_factors(self) -> list[int]: ...

    def get_max_tuple_index(self) -> int: ...

    def get_empty_tuple_index(self) -> int: ...

UNSOLVABLE: SearchStatus = SearchStatus.UNSOLVABLE

def compute_state_metric_value(state: State, problem: pymimir.advanced.formalism.Problem) -> float: ...

def find_solution_astar(search_context: SearchContext, heuristic: IHeuristic, start_state: Optional[State] = None, astar_event_handler: Optional[IAStarEventHandler] = None, goal_strategy: Optional[IGoalStrategy] = None, pruning_strategy: Optional[IPruningStrategy] = None) -> SearchResult: ...

def find_solution_brfs(search_context: SearchContext, start_state: Optional[State] = None, brfs_event_handler: Optional[IBrFSEventHandler] = None, goal_strategy: Optional[IGoalStrategy] = None, pruning_strategy: Optional[IPruningStrategy] = None, exhaustive: bool = False) -> SearchResult: ...

def find_solution_iw(search_context: SearchContext, start_state: Optional[State] = None, max_arity: Optional[int] = None, iw_event_handler: Optional[IIWEventHandler] = None, brfs_event_handler: Optional[IBrFSEventHandler] = None, goal_strategy: Optional[IGoalStrategy] = None) -> SearchResult: ...

def find_solution_siw(search_context: SearchContext, start_state: Optional[State] = None, max_arity: Optional[int] = None, siw_event_handler: Optional[ISIWEventHandler] = None, iw_event_handler: Optional[IIWEventHandler] = None, brfs_event_handler: Optional[IBrFSEventHandler] = None, goal_strategy: Optional[IGoalStrategy] = None) -> SearchResult: ...
