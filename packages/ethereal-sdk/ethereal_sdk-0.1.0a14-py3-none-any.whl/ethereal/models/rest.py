# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2025-04-16T17:25:17+00:00

from __future__ import annotations

from decimal import Decimal
from enum import Enum
from typing import List, Optional, Union

from pydantic import BaseModel, Field, confloat, constr


class SystemTimeDto(BaseModel):
    time: float = Field(
        ...,
        description="Current system timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )


class SubaccountDto(BaseModel):
    id: str = Field(
        ...,
        description="Id representing the registered subaccount",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    name: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    account: str = Field(
        ...,
        description="Address of the account which registered the subaccount",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    created_block_number: str = Field(
        ...,
        alias="createdBlockNumber",
        description="Block number this subaccount was created on",
        examples=["123062737"],
    )
    registered_block_number: Optional[str] = Field(
        None,
        alias="registeredBlockNumber",
        description="Block number this subaccount was registered on",
        examples=["123062737"],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Subaccount creation timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )


class PageOfSubaccountDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[SubaccountDto] = Field(..., description="Array of subaccount objects")


class SubaccountBalanceDto(BaseModel):
    subaccount_id: str = Field(
        ...,
        alias="subaccountId",
        description="Id representing the subaccount",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    token_id: str = Field(
        ...,
        alias="tokenId",
        description="Id representing the token",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    token_address: str = Field(
        ...,
        alias="tokenAddress",
        description="ERC20 deposited token address (zero address if virtual)",
        examples=["0x70997970C51812dc3A010C7d01b50e0d17dc79C8"],
    )
    token_name: str = Field(
        ...,
        alias="tokenName",
        description="The unique exchange defined token name driven by addToken onchain",
        examples=["ETH"],
    )
    amount: Decimal = Field(
        ...,
        description="Token balance in native units expressed as a decimal (precision: 9)",
        examples=["1.5"],
    )
    available: Decimal = Field(
        ...,
        description="Portion of balance transferrable in native units expressed as a decimal (precision: 9)",
        examples=["0.1337"],
    )
    total_used: Decimal = Field(
        ...,
        alias="totalUsed",
        description="Portion of balance non-transferrable in native units expressed as a decimal (precision: 9)",
        examples=["1.3663"],
    )
    updated_at: float = Field(
        ...,
        alias="updatedAt",
        description="Token balance last updated timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )


class PageOfSubaccountBalanceDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[SubaccountBalanceDto] = Field(
        ..., description="Array of order subaccount balances"
    )


class LinkSignerDtoData(BaseModel):
    subaccount_id: str = Field(
        ...,
        alias="subaccountId",
        description="Id representing the registered subaccount",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    sender: str = Field(
        ...,
        description="Address of account that created the signature in this message",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    signer: str = Field(
        ...,
        description="Address of signer to allowed for delegated signing",
        examples=["0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"],
    )
    nonce: str = Field(
        ...,
        description="Message nonce timestamp (nanoseconds since Unix Epoch)",
        examples=["2687929537462333"],
    )
    signed_at: float = Field(
        ...,
        alias="signedAt",
        description="Message signedAt current timestamp (seconds since Unix Epoch)",
        examples=[1712019600],
    )


class LinkSignerDto(BaseModel):
    signature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the sender"
    )
    signer_signature: str = Field(
        ...,
        alias="signerSignature",
        description="The signature from signTypedData(...) signed by the signer",
    )
    data: LinkSignerDtoData


class SignerDto(BaseModel):
    id: str = Field(
        ...,
        description="Id representing the linked signer",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    signer: str = Field(
        ...,
        description="Address of the signer linked with the subaccount",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    is_active: bool = Field(
        ...,
        alias="isActive",
        description="Whether this signer is the current active signer for the subaccount",
        examples=[True],
    )
    block_number: Optional[str] = Field(
        None,
        alias="blockNumber",
        description="Block number the signer has been linked on. Undefined means it has not be processed",
        examples=["123062737"],
    )
    linked_at: Optional[float] = Field(
        None,
        alias="linkedAt",
        description="Onchain linkage timestamp (ms since Unix Epoch)",
        examples=[1712019615000],
    )
    expires_at: float = Field(
        ...,
        alias="expiresAt",
        description="Signer expiry timestamp (ms since Unix Epoch)",
        examples=[1713229200000],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Link signer submission timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )


class RevokeLinkedSignerDtoData(BaseModel):
    subaccount_id: str = Field(
        ...,
        alias="subaccountId",
        description="Id representing the registered subaccount",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    sender: str = Field(
        ...,
        description="Address of account that created the signature in this message",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    signer: str = Field(
        ...,
        description="Address of signer to revoke",
        examples=["0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"],
    )
    nonce: str = Field(
        ...,
        description="Message nonce timestamp (nanoseconds since Unix Epoch)",
        examples=["2687929537462333"],
    )
    signed_at: float = Field(
        ...,
        alias="signedAt",
        description="Message signedAt current timestamp (seconds since Unix Epoch)",
        examples=[1712019600],
    )


class RevokeLinkedSignerDto(BaseModel):
    signature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the sender"
    )
    data: RevokeLinkedSignerDtoData


class AccountSignerQuotaDto(BaseModel):
    max_linked_signers_period_days: float = Field(
        ...,
        alias="maxLinkedSignersPeriodDays",
        description="Ratelimit period in days for linking signers per account",
        examples=[7],
    )
    max_linked_signers_in_period: float = Field(
        ...,
        alias="maxLinkedSignersInPeriod",
        description="Max number of signer that can be linked within ratelimit period",
        examples=[10],
    )
    linked_signers_used_in_period: float = Field(
        ...,
        alias="linkedSignersUsedInPeriod",
        description="Number of signers linked within current ratelimit period",
        examples=[2],
    )


class PageOfSignersDto(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[SignerDto] = Field(..., description="Array of signer objects")


class Status(Enum):
    submitted = "SUBMITTED"
    pending = "PENDING"
    completed = "COMPLETED"
    rejected = "REJECTED"


class WithdrawDto(BaseModel):
    id: str = Field(
        ...,
        description="Id representing the withdraw",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    initiated_block_number: Optional[str] = Field(
        None,
        alias="initiatedBlockNumber",
        description="Block number the withdraw was initiated on",
        examples=["123062000"],
    )
    finalized_block_number: Optional[str] = Field(
        None,
        alias="finalizedBlockNumber",
        description="Block number the withdraw was completed on",
        examples=["123062992"],
    )
    status: Status = Field(
        ..., description="Current status of the withdraw", examples=["PENDING"]
    )
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    token: str = Field(
        ...,
        description="Address of asset withdraw",
        examples=["0xF3FC178157fb3c87548bAA86F9d24BA38E649B58"],
    )
    amount: str = Field(
        ...,
        description="Amount of asset transferred expressed as a decimal",
        examples=["1.5"],
    )
    is_ready: bool = Field(
        ...,
        alias="isReady",
        description="Indicates whether a withdraw is ready to be finalized onchain",
        examples=[True],
    )
    ready_at: Optional[confloat(ge=1.0)] = Field(
        None,
        alias="readyAt",
        description="Ready to be withdrawn onchain estimated timestamp (ms since Unix Epoch)",
        examples=[1712019615000],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Withdraw creation timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )


class PageOfWithdrawDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[WithdrawDto] = Field(
        ..., description="Array of subaccount withdraw objects"
    )


class Type(Enum):
    deposit = "DEPOSIT"
    fees_claimed = "FEES_CLAIMED"
    withdraw = "WITHDRAW"


class TransferDto(BaseModel):
    id: str = Field(
        ...,
        description="Id representing the transfer",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    initiated_block_number: Optional[str] = Field(
        None,
        alias="initiatedBlockNumber",
        description="Block number the transfer was initiated on",
        examples=["123062000"],
    )
    finalized_block_number: Optional[str] = Field(
        None,
        alias="finalizedBlockNumber",
        description="Block number the transfer was completed on",
        examples=["123062992"],
    )
    status: Status = Field(
        ..., description="Current status of the transfer", examples=["PENDING"]
    )
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    token: str = Field(
        ...,
        description="Address of token transferred",
        examples=["0xF3FC178157fb3c87548bAA86F9d24BA38E649B58"],
    )
    type: Type = Field(
        ..., description="Type of transfer (WITHDRAW or DEPOSIT)", examples=["WITHDRAW"]
    )
    amount: str = Field(
        ...,
        description="Amount of tokens transferred in native units expressed as a decimal (precision: 9)",
        examples=["0.42"],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Transfer creation timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )
    initiated_transaction_hash: Optional[str] = Field(
        None,
        alias="initiatedTransactionHash",
        description="Transaction hash for the initiation of the transfer",
        examples=["0xF3FC178157fb3c87548bAA86F9d24BA38E649B58"],
    )
    finalized_transaction_hash: Optional[str] = Field(
        None,
        alias="finalizedTransactionHash",
        description="Transaction hash for the finalization of the transfer",
        examples=["0xF3FC178157fb3c87548bAA86F9d24BA38E649B58"],
    )


class PageOfTransfersDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[TransferDto] = Field(..., description="Array of transfer objects")


class InitiateWithdrawDtoData(BaseModel):
    account: str = Field(
        ...,
        description="Account address",
        examples=["0x70997970C51812dc3A010C7d01b50e0d17dc79C8"],
    )
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    token: str = Field(
        ...,
        description="Address of token to be withdrawn",
        examples=["0x5FC8d32690cc91D4c39d9d3abcBD16989F875707"],
    )
    amount: Decimal = Field(
        ...,
        description="Amount to withdraw in native units expressed as a decimal (precision: 9)",
        examples=["1337.42"],
    )
    nonce: str = Field(
        ...,
        description="Message nonce timestamp (nanoseconds since Unix Epoch)",
        examples=["2687929537462333"],
    )
    signed_at: float = Field(
        ...,
        alias="signedAt",
        description="Message signedAt current timestamp (seconds since Unix Epoch)",
        examples=[1712019600],
    )


class InitiateWithdrawDto(BaseModel):
    signature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the sender"
    )
    data: InitiateWithdrawDtoData


class TokenDto(BaseModel):
    id: str = Field(
        ...,
        description="Id representing the token",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    address: str = Field(
        ...,
        description="Address of the token (zero address virtual)",
        examples=["0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"],
    )
    name: str = Field(
        ...,
        description="The unique exchange defined token name driven by addToken onchain",
        examples=["ETH"],
    )
    erc20_name: Optional[str] = Field(
        None,
        alias="erc20Name",
        description="ERC20 token name (available if not virtual)",
        examples=["Wrapped Ether"],
    )
    erc20_symbol: Optional[str] = Field(
        None,
        alias="erc20Symbol",
        description="ERC20 token symbol (available if not virtual)",
        examples=["WETH"],
    )
    erc20_decimals: Optional[float] = Field(
        None,
        alias="erc20Decimals",
        description="ERC20 token decimals (available if not virtual)",
        examples=[18],
    )
    deposit_enabled: bool = Field(
        ...,
        alias="depositEnabled",
        description="Whether the token is enabled for deposit",
        examples=[True],
    )
    withdraw_enabled: bool = Field(
        ...,
        alias="withdrawEnabled",
        description="Whether the token is enabled for withdraw",
        examples=[True],
    )
    deposit_fee: str = Field(
        ...,
        alias="depositFee",
        description="Amount of native units charged on deposit expressed as a decimal (precision: 9)",
        examples=["0"],
    )
    withdraw_fee: str = Field(
        ...,
        alias="withdrawFee",
        description="Amount of native units charged on withdraw expressed as a decimal (precision: 9)",
        examples=["0.0001"],
    )
    min_deposit: str = Field(
        ...,
        alias="minDeposit",
        description="Min deposit amount as native units expressed as a decimal (precision: 9)",
        examples=["0.1"],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Token creation timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )


class PageOfTokensDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[TokenDto] = Field(..., description="Array of token objects")


class DomainTypeDto(BaseModel):
    name: str = Field(..., description="Name of signing domain")
    version: str = Field(..., description="Current major version of the signing domain")
    chain_id: float = Field(..., alias="chainId", description="The EIP-155 chain id")
    verifying_contract: str = Field(
        ...,
        alias="verifyingContract",
        description="Address of the contract that will verify the signature",
    )


class SignatureTypesDto(BaseModel):
    link_signer: str = Field(
        ..., alias="LinkSigner", description="LinkSigner signature type"
    )
    trade_order: str = Field(
        ..., alias="TradeOrder", description="TradeOrder signature type"
    )
    initiate_withdraw: str = Field(
        ..., alias="InitiateWithdraw", description="InitiateWithdraw signature type"
    )
    update_funding: str = Field(
        ..., alias="UpdateFunding", description="UpdateFunding signature type"
    )
    revoke_linked_signer: str = Field(
        ..., alias="RevokeLinkedSigner", description="RevokeLinkedSigner signature type"
    )
    cancel_order: str = Field(
        ..., alias="CancelOrder", description="CancelOrder signature type"
    )


class RpcConfigDto(BaseModel):
    domain: DomainTypeDto = Field(..., description="Domain type")
    signature_types: SignatureTypesDto = Field(
        ..., alias="signatureTypes", description="Signature types"
    )


class Type1(Enum):
    limit = "LIMIT"
    market = "MARKET"


class Side(Enum):
    buy = 0
    sell = 1


class Status2(Enum):
    canceled = "CANCELED"
    expired = "EXPIRED"
    filled = "FILLED"
    filled_partial = "FILLED_PARTIAL"
    new = "NEW"
    pending = "PENDING"
    rejected = "REJECTED"
    submitted = "SUBMITTED"


class StopType(Enum):
    gain = 0
    loss = 1


class StopPriceType(Enum):
    last_price = 0
    mark_price = 1


class TimeInForce(Enum):
    gtd = "GTD"
    ioc = "IOC"
    fok = "FOK"


class OtocoTriggerType(Enum):
    oto = 0
    oco = 1


class OrderDto(BaseModel):
    id: str = Field(
        ...,
        description="Id representing the order",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    type: Type1 = Field(
        ..., description="Trade order type e.g. MARKET or LIMIT", examples=["LIMIT"]
    )
    available_quantity: str = Field(
        ...,
        alias="availableQuantity",
        description="Remaining quantity (if modified or reduced) in native units expressed as a decimal (precision: 9)",
        examples=["10.5"],
    )
    quantity: str = Field(
        ...,
        description="Original quantity (as per order submission) in native units expressed as a decimal (precision: 9)",
        examples=["10.5"],
    )
    side: Side = Field(
        ..., description="Side as either BUY (0) or SELL (1)", examples=[1]
    )
    product_id: str = Field(
        ...,
        alias="productId",
        description="Id of product this order was placed against",
        examples=["9c6bf870-a8ce-4de3-820b-542fd5c049ba"],
    )
    subaccount_id: str = Field(
        ...,
        alias="subaccountId",
        description="Id of the subaccount associated to order",
        examples=["c25c39d9-ce2b-4753-960c-c5ad558aace8"],
    )
    status: Status2 = Field(..., description="Status of the order", examples=["FILLED"])
    reduce_only: bool = Field(
        ...,
        alias="reduceOnly",
        description="Indicates if the order is reduce only",
        examples=[True],
    )
    close: bool = Field(..., description="Order closes the entire current position")
    updated_at: float = Field(
        ...,
        alias="updatedAt",
        description="Order last updated timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Order creation timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )
    sender: str = Field(
        ...,
        description="Account or linked signer address that originally submitted this order",
        examples=["0x2501c477d0a35545a387aa4a3eee4292a9a8b3f0"],
    )
    price: str = Field(
        ...,
        description="Limit price in native units expressed as a decimal, zero if market order (precision: 9)",
        examples=["4200.5"],
    )
    filled: str = Field(
        ...,
        description="Filled amount in native units expressed as a decimal (precision: 9)",
        examples=["0.5"],
    )
    stop_price: str = Field(
        ...,
        alias="stopPrice",
        description="Stop price expressed as a decimal (zero if not a stop order, precision: 9)",
        examples=["4200.5"],
    )
    stop_type: Optional[StopType] = Field(
        None,
        alias="stopType",
        description="Side as either BUY (0) or SELL (1)",
        examples=[1],
    )
    stop_price_type: Optional[StopPriceType] = Field(
        None,
        alias="stopPriceType",
        description="Type of stop price (stop orders only)",
        examples=[1],
    )
    time_in_force: Optional[TimeInForce] = Field(
        None,
        alias="timeInForce",
        description="How long an order will remain until executed/expired (required if limit)",
        examples=["GTD"],
    )
    expires_at: float = Field(
        ...,
        alias="expiresAt",
        description="Order expiry timestamp (seconds since Unix Epoch)",
        examples=[1712019600],
    )
    post_only: Optional[bool] = Field(
        None,
        alias="postOnly",
        description="Only add order if it does not immediately fill (limit only)",
        examples=[True],
    )
    otoco_trigger_type: Optional[OtocoTriggerType] = Field(
        None,
        alias="otocoTriggerType",
        description="Type of OTOCO relationship (OTO or OCO)",
        examples=[0],
    )
    otoco_group_id: Optional[str] = Field(
        None,
        alias="otocoGroupId",
        description="Id of the OTOCO group this order belongs to",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )


class PageOfOrderDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[OrderDto] = Field(..., description="Array of order objects")


class Type2(Enum):
    market = "MARKET"


class EngineType(Enum):
    perp = 0
    spot = 1


class SubmitOrderMarketDtoData(BaseModel):
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    sender: str = Field(
        ...,
        description="Address of account",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    nonce: str = Field(
        ...,
        description="Message nonce timestamp (nanoseconds since Unix Epoch)",
        examples=["2687929537462333"],
    )
    type: Type2 = Field(..., description="Market order type", examples=["MARKET"])
    quantity: Decimal = Field(
        ...,
        description="Quantity of product in native units expressed as a decimal (precision: 9)",
        examples=["5.5"],
    )
    side: Side = Field(
        ..., description="Side as either BUY (0) or SELL (1)", examples=[1]
    )
    onchain_id: confloat(ge=1.0) = Field(
        ...,
        alias="onchainId",
        description="Onchain generated productId from prior product registration",
        examples=[1],
    )
    engine_type: EngineType = Field(
        ...,
        alias="engineType",
        description="Product engine type e.g. PERP (0)",
        examples=[0],
    )
    reduce_only: Optional[bool] = Field(
        False,
        alias="reduceOnly",
        description="Whether this should be a reduce-only order, required for close",
    )
    close: Optional[bool] = Field(
        False,
        description="Order closes the entire current position, requires zero quantity and reduceOnly",
    )
    stop_price: Optional[Decimal] = Field(
        Decimal("0"),
        alias="stopPrice",
        description="Stop price expressed as a decimal (precision: 9), requires stopType",
        examples=["4200.5"],
    )
    stop_type: Optional[StopType] = Field(
        None,
        alias="stopType",
        description="Stop type, either 0 (take-profit) or 1 (stop-loss), requires non-zero stopPrice",
        examples=[1],
    )
    signed_at: float = Field(
        ...,
        alias="signedAt",
        description="Message signedAt current timestamp (seconds since Unix Epoch)",
        examples=[1712019600],
    )
    expires_at: Optional[float] = Field(
        None,
        alias="expiresAt",
        description="Order expiry timestamp (seconds since Unix Epoch), defaults to the maximum allowed value: signedAt + 6652800",
    )
    otoco_trigger: Optional[bool] = Field(
        False,
        alias="otocoTrigger",
        description="Set if this order should be the OTO order in a new OTOCO group for triggering stop-loss/take-profit orders (precludes otocoGroup)",
    )
    otoco_group_id: Optional[str] = Field(
        None,
        alias="otocoGroupId",
        description="Id of an existing OTOCO group this order will join as an OCO order (precludes otocoTrigger)",
    )


class Type3(Enum):
    limit = "LIMIT"


class SubmitOrderLimitDtoData(BaseModel):
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    sender: str = Field(
        ...,
        description="Address of account",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    nonce: str = Field(
        ...,
        description="Message nonce timestamp (nanoseconds since Unix Epoch)",
        examples=["2687929537462333"],
    )
    type: Type3 = Field(..., description="Limit order type", examples=["LIMIT"])
    quantity: Decimal = Field(
        ...,
        description="Quantity of product in native units expressed as a decimal (precision: 9)",
        examples=["5.5"],
    )
    side: Side = Field(
        ..., description="Side as either BUY (0) or SELL (1)", examples=[1]
    )
    onchain_id: confloat(ge=1.0) = Field(
        ...,
        alias="onchainId",
        description="Onchain generated productId from prior product registration",
        examples=[1],
    )
    engine_type: EngineType = Field(
        ...,
        alias="engineType",
        description="Product engine type e.g. PERP (0)",
        examples=[0],
    )
    reduce_only: Optional[bool] = Field(
        False,
        alias="reduceOnly",
        description="Whether this should be a reduce-only order, required for close",
    )
    close: Optional[bool] = Field(
        False,
        description="Order closes the entire current position, requires zero quantity and reduceOnly",
    )
    stop_price: Optional[Decimal] = Field(
        Decimal("0"),
        alias="stopPrice",
        description="Stop price expressed as a decimal (precision: 9), requires stopType",
        examples=["4200.5"],
    )
    stop_type: Optional[StopType] = Field(
        None,
        alias="stopType",
        description="Stop type, either 0 (take-profit) or 1 (stop-loss), requires non-zero stopPrice",
        examples=[1],
    )
    signed_at: float = Field(
        ...,
        alias="signedAt",
        description="Message signedAt current timestamp (seconds since Unix Epoch)",
        examples=[1712019600],
    )
    expires_at: Optional[float] = Field(
        None,
        alias="expiresAt",
        description="Order expiry timestamp (seconds since Unix Epoch), defaults to the maximum allowed value: signedAt + 6652800",
    )
    otoco_trigger: Optional[bool] = Field(
        False,
        alias="otocoTrigger",
        description="Set if this order should be the OTO order in a new OTOCO group for triggering stop-loss/take-profit orders (precludes otocoGroup)",
    )
    otoco_group_id: Optional[str] = Field(
        None,
        alias="otocoGroupId",
        description="Id of an existing OTOCO group this order will join as an OCO order (precludes otocoTrigger)",
    )
    price: Decimal = Field(
        ...,
        description="Limit price expressed as a decimal (precision: 9)",
        examples=["4200.5"],
    )
    time_in_force: TimeInForce = Field(
        ...,
        alias="timeInForce",
        description="How long an order will remain until executed/expired",
        examples=["IOC"],
    )
    post_only: bool = Field(
        ...,
        alias="postOnly",
        description="Only add order if it does not immediately fill",
        examples=[True],
    )


class SubmitOrderDto(BaseModel):
    data: Union[SubmitOrderMarketDtoData, SubmitOrderLimitDtoData]
    signature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the sender"
    )


class SubmitDryOrderDto(BaseModel):
    data: Union[SubmitOrderMarketDtoData, SubmitOrderLimitDtoData]


class RejectReason(Enum):
    technical_error = "TechnicalError"
    immediate_match_post_only = "ImmediateMatchPostOnly"
    risk_limit_exceeded = "RiskLimitExceeded"
    order_increases_position = "OrderIncreasesPosition"
    unfilled_immediate_or_cancel = "UnfilledImmediateOrCancel"
    unfilled_fill_or_kill = "UnfilledFillOrKill"
    insufficient_balance = "InsufficientBalance"
    liquidation = "Liquidation"
    unfilled_market_order = "UnfilledMarketOrder"
    instrument_open_value_cap_exceeded = "InstrumentOpenValueCapExceeded"
    trigger_canceled = "TriggerCanceled"
    oco_filled = "OcoFilled"
    user_set_timeout_reached = "UserSetTimeoutReached"
    instrument_expired = "InstrumentExpired"
    pegged_order_price_above_max_price = "PeggedOrderPriceAboveMaxPrice"
    pegged_order_price_below_min_price = "PeggedOrderPriceBelowMinPrice"
    no_liquidity_for_peg = "NoLiquidityForPeg"
    market_order_reached_max_slippage = "MarketOrderReachedMaxSlippage"
    causes_immediate_liquidation = "CausesImmediateLiquidation"
    unknown = "Unknown"
    engine_bad_request = "EngineBadRequest"
    not_found = "NotFound"


class OrderDryRunDto(BaseModel):
    margin_required: str = Field(
        ...,
        alias="marginRequired",
        description="Margin required for order in USD expressed as a decimal (precision: 9)",
        examples=["1000.5"],
    )
    margin_available: str = Field(
        ...,
        alias="marginAvailable",
        description="Margin available excluding this order in USD expressed as a decimal (precision: 9)",
        examples=["5000.75"],
    )
    total_used_margin: str = Field(
        ...,
        alias="totalUsedMargin",
        description="Total used margin including this order in USD expressed as a decimal (precision: 9)",
        examples=["3000.25"],
    )
    risk_used: str = Field(
        ...,
        alias="riskUsed",
        description="Risk used including position and open orders in USD expressed as a decimal (precision: 9)",
        examples=["3000.25"],
    )
    risk_available: str = Field(
        ...,
        alias="riskAvailable",
        description="Risk available for the product in USD expressed as a decimal (precision: 9)",
        examples=["100000000"],
    )
    reject_reason: Optional[RejectReason] = Field(
        None,
        alias="rejectReason",
        description="Reason for rejecting the order, undefined if accepted",
        examples=["InsufficientBalance"],
    )


class CancelOrderDtoData(BaseModel):
    subaccount: str = Field(
        ...,
        description="Bytes32 encoded name of the subaccount (with 0x prefix)",
        examples=["0x7072696d61727900000000000000000000000000000000000000000000000000"],
    )
    sender: str = Field(
        ...,
        description="Address of account that created the signature in this message",
        examples=["0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe"],
    )
    nonce: str = Field(
        ...,
        description="Message nonce timestamp (nanoseconds since Unix Epoch)",
        examples=["2687929537462333"],
    )
    order_ids: List[str] = Field(
        ...,
        alias="orderIds",
        description="Ids of the orders to be canceled",
        examples=[["80569be0-afba-43f8-ac20-767d0974c6a3"]],
        max_length=256,
        min_length=1,
    )


class CancelOrderDto(BaseModel):
    signature: str = Field(
        ..., description="The signature from signTypedData(...) signed by the sender"
    )
    data: CancelOrderDtoData


class FailureReason(Enum):
    already_canceled = "ALREADY_CANCELED"
    already_expired = "ALREADY_EXPIRED"
    already_filled = "ALREADY_FILLED"
    not_found = "NOT_FOUND"


class CancelOrderResultDto(BaseModel):
    id: str = Field(
        ...,
        description="Id representing the order",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    success: bool = Field(
        ..., description="Whether the order was successfully canceled", examples=[False]
    )
    failure_reason: Optional[FailureReason] = Field(
        None, alias="failureReason", description="Reason for cancelation failure"
    )


class ListOfCancelOrderResultDtos(BaseModel):
    data: List[CancelOrderResultDto] = Field(
        ..., description="Array of order cancelation results"
    )


class Type4(Enum):
    limit = "LIMIT"
    market = "MARKET"


class OrderFillDto(BaseModel):
    order_id: str = Field(
        ...,
        alias="orderId",
        description="Id of the order",
        examples=["b1234567-89ab-cdef-0123-456789abcdef"],
    )
    price: str = Field(
        ...,
        description="Fill price in expressed as a decimal (precision: 9)",
        examples=["4200.5"],
    )
    filled: str = Field(
        ...,
        description="Quantity filled in native units expressed as a decimal (precision: 9)",
        examples=["2.420"],
    )
    type: Type4 = Field(
        ...,
        description="The provided subaccount's order type e.g. MARKET or LIMIT",
        examples=["LIMIT"],
    )
    side: Side = Field(
        ..., description="Side as either BUY (0) or SELL (1)", examples=[1]
    )
    reduce_only: bool = Field(
        ...,
        alias="reduceOnly",
        description="Indicates if the fill is reduce only",
        examples=[True],
    )
    fee_usd: str = Field(
        ...,
        alias="feeUsd",
        description="The provided subaccount's charged fee in USD expressed as a decimal (precision: 9)",
        examples=["3.049563"],
    )
    is_maker: bool = Field(
        ...,
        alias="isMaker",
        description="Indicates if the fill was a maker or taker",
        examples=[True],
    )
    product_id: str = Field(
        ...,
        alias="productId",
        description="Id of product the order fill was made against",
        examples=["9c6bf870-a8ce-4de3-820b-542fd5c049ba"],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Fill creation timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )


class PageOfOrderFillDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[OrderFillDto] = Field(..., description="Array of order fill objects")


class MakerSide(Enum):
    buy = 0
    sell = 1


class TakerSide(Enum):
    buy = 0
    sell = 1


class TradeDto(BaseModel):
    id: str = Field(
        ...,
        description="Id representing the trade",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    taker_order_id: str = Field(
        ...,
        alias="takerOrderId",
        description="Id of the taker order",
        examples=["b1234567-89ab-cdef-0123-456789abcdef"],
    )
    maker_order_id: str = Field(
        ...,
        alias="makerOrderId",
        description="Id of the maker order",
        examples=["e3f0a8b7-6daa-498a-bf53-c16dc5e779de"],
    )
    maker_fee_usd: str = Field(
        ...,
        alias="makerFeeUsd",
        description="Maker fee in USD expressed as a decimal (precision: 9)",
        examples=["3.049563"],
    )
    taker_fee_usd: str = Field(
        ...,
        alias="takerFeeUsd",
        description="Taker fee in USD expressed as a decimal (precision: 9)",
        examples=["4.5743445"],
    )
    price: str = Field(
        ...,
        description="Price expressed as a decimal (precision: 9)",
        examples=["4200.5"],
    )
    filled: str = Field(
        ...,
        description="Quantity filled in native units expressed as a decimal (precision: 9)",
        examples=["2.420"],
    )
    maker_side: MakerSide = Field(
        ...,
        alias="makerSide",
        description="Maker side as either BUY (0) or SELL (1)",
        examples=[1],
    )
    taker_side: TakerSide = Field(
        ...,
        alias="takerSide",
        description="Taker side as either BUY (0) or SELL (1)",
        examples=[0],
    )
    product_id: str = Field(
        ...,
        alias="productId",
        description="Id of product the trade was made against",
        examples=["9c6bf870-a8ce-4de3-820b-542fd5c049ba"],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Trade creation timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )


class PageOfTradeDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[TradeDto] = Field(..., description="Array of trade objects")


class PositionDto(BaseModel):
    id: str = Field(
        ...,
        description="Id representing the position",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    cost: str = Field(
        ...,
        description="Current cost of the position in USD expressed as a decimal (precision: 9)",
        examples=["9.3"],
    )
    size: str = Field(
        ...,
        description="Position size in native units expressed as a decimal (precision: 9)",
        examples=["1.5"],
    )
    funding_usd: str = Field(
        ...,
        alias="fundingUsd",
        description="Amount in USD since position was opened expressed as a decimal (precision: 9)",
        examples=["10.5"],
    )
    fees_accrued_usd: str = Field(
        ...,
        alias="feesAccruedUsd",
        description="Fees accrued in USD expressed as a decimal (precision: 9)",
        examples=["0.5"],
    )
    realized_pnl: str = Field(
        ...,
        alias="realizedPnl",
        description="Realized PnL in USD expressed as a decimal (precision: 9)",
        examples=["-12.5"],
    )
    total_increase_notional: str = Field(
        ...,
        alias="totalIncreaseNotional",
        description="Cumulative USD value of all position increases expressed as a decimal (precision: 9)",
        examples=["1000.0"],
    )
    total_increase_quantity: str = Field(
        ...,
        alias="totalIncreaseQuantity",
        description="Cumulative quantity of all position increases expressed as a decimal (precision: 9)",
        examples=["2.5"],
    )
    total_decrease_notional: str = Field(
        ...,
        alias="totalDecreaseNotional",
        description="Cumulative USD value of all position decreases expressed as a decimal (precision: 9)",
        examples=["1050.0"],
    )
    total_decrease_quantity: str = Field(
        ...,
        alias="totalDecreaseQuantity",
        description="Cumulative quantity of all position decreases expressed as a decimal (precision: 9)",
        examples=["2.5"],
    )
    side: Side = Field(
        ..., description="Side as either BUY (0) or SELL (1)", examples=[0]
    )
    product_id: str = Field(
        ...,
        alias="productId",
        description="Id of product to this position belongs to",
        examples=["9c6bf870-a8ce-4de3-820b-542fd5c049ba"],
    )
    updated_at: float = Field(
        ...,
        alias="updatedAt",
        description="Position last updated timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Position creation timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )


class PageOfPositionDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[PositionDto] = Field(..., description="Array of position objects")


class Type5(Enum):
    limit = "LIMIT"
    market = "MARKET"
    liquidation = "LIQUIDATION"


class PositionFillDto(BaseModel):
    price: str = Field(
        ...,
        description="Fill price expressed as a decimal (precision: 9)",
        examples=["4200.5"],
    )
    filled: str = Field(
        ...,
        description="Quantity filled in native units expressed as a decimal (precision: 9)",
        examples=["2.420"],
    )
    type: Type5 = Field(
        ...,
        description="Corresponding order type that led to the position fill, LIQUIDATED if takeover",
        examples=["LIMIT"],
    )
    side: Side = Field(
        ...,
        description="Direction of the fill as either BUY (0) or SELL (1)",
        examples=[1],
    )
    reduce_only: bool = Field(
        ...,
        alias="reduceOnly",
        description="Indicates if the fill is reduce only",
        examples=[False],
    )
    fee_usd: str = Field(
        ...,
        alias="feeUsd",
        description="The charged fee in USD expressed as a decimal (precision: 9)",
        examples=["3.049563"],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Fill creation timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )


class PageOfPositionFillDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[PositionFillDto] = Field(
        ..., description="Array of position fill objects"
    )


class ProductDto(BaseModel):
    id: str = Field(
        ...,
        description="Id representing the registered product",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    ticker: str = Field(
        ...,
        description="Product ticker based on the base quote token",
        examples=["ETHUSD"],
    )
    display_ticker: str = Field(
        ...,
        alias="displayTicker",
        description="Product display ticker based on the base quote token",
        examples=["ETH/USD"],
    )
    base_token_address: str = Field(
        ...,
        alias="baseTokenAddress",
        description="Address of the base token (zero address if virtual)",
        examples=["0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"],
    )
    quote_token_address: str = Field(
        ...,
        alias="quoteTokenAddress",
        description="Address of quote token",
        examples=["0x4c9edd5852cd905f086c759e8383e09bff1e68b3"],
    )
    base_token_name: str = Field(
        ...,
        alias="baseTokenName",
        description="Name of the base token (e.g. BTC in BTCUSD)",
        examples=["ETH"],
    )
    quote_token_name: str = Field(
        ...,
        alias="quoteTokenName",
        description="Name of the quote token (e.g. USD in BTCUSD)",
        examples=["USDe"],
    )
    engine_type: EngineType = Field(
        ...,
        alias="engineType",
        description="The corresponding engine type this product was registered with",
        examples=[0],
    )
    onchain_id: float = Field(
        ...,
        alias="onchainId",
        description="The productId generated onchain after registering for the first time",
        examples=[1],
    )
    block_number: str = Field(
        ...,
        alias="blockNumber",
        description="Block number this product was registered on",
        examples=["123062737"],
    )
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Product creation timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )
    funding_updated_at: Optional[float] = Field(
        None,
        alias="fundingUpdatedAt",
        description="Unix timestamp when funding was last updated",
        examples=[1721724269],
    )
    min_quantity: str = Field(
        ...,
        alias="minQuantity",
        description="The minimum order quantity in native units expressed as a decimal (precision: 9)",
        examples=["0.05"],
    )
    lot_size: str = Field(
        ...,
        alias="lotSize",
        description="Quantity must be divisible by the lotSize in expressed as a decimal (precision: 9)",
        examples=["0.01"],
    )
    tick_size: str = Field(
        ...,
        alias="tickSize",
        description="Minimum price increment (tickSize) expressed as a decimal (precision: 9)",
        examples=["0.0001"],
    )
    maker_fee: str = Field(
        ...,
        alias="makerFee",
        description="Fee charged to the maker on order trades expressed as a decimal (precision: 9)",
        examples=["0.001"],
    )
    taker_fee: str = Field(
        ...,
        alias="takerFee",
        description="Fee charged to the taker on order trades expressed as a decimal (precision: 9)",
        examples=["0.004"],
    )
    max_quantity: str = Field(
        ...,
        alias="maxQuantity",
        description="Max quantity per order in native units expressed as a decimal (precision: 9)",
        examples=["100000"],
    )
    min_price: str = Field(
        ...,
        alias="minPrice",
        description="Min price in USD expressed as a decimal (precision: 9)",
        examples=["0"],
    )
    max_price: str = Field(
        ...,
        alias="maxPrice",
        description="Max price in USD expressed as a decimal (precision: 9)",
        examples=["100000"],
    )
    volume24h: str = Field(
        ...,
        description="24h volume in base token native units expressed as a decimal (precision: 9)",
        examples=["500000000.42"],
    )
    max_leverage: float = Field(
        ...,
        alias="maxLeverage",
        description="Maximum leverage allowed for the product",
        examples=[20],
    )
    pyth_feed_id: float = Field(
        ..., alias="pythFeedId", description="Pyth price feed id", examples=[2]
    )
    funding_rate1h: str = Field(
        ...,
        alias="fundingRate1h",
        description="Last computed hourly funding rate expressed as a decimal (precision: 9)",
        examples=["0.01"],
    )
    open_interest: str = Field(
        ...,
        alias="openInterest",
        description="Open interest in native units expressed as a decimal (precision: 9)",
        examples=["3300.17"],
    )
    max_open_interest: str = Field(
        ...,
        alias="maxOpenInterest",
        description="Max open interest in native units expressed as a decimal (precision: 9)",
        examples=["200000000.0"],
    )


class PageOfProductDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[ProductDto] = Field(..., description="Array of product objects")


class MarketLiquidityDto(BaseModel):
    timestamp: float = Field(
        ...,
        description="Unix timestamp in ms of the most recent market liquidity update",
        examples=[1731664105881],
    )
    previous_timestamp: float = Field(
        ...,
        alias="previousTimestamp",
        description="Unix timestamp in ms of the previous market liquidity update",
        examples=[1731664105881],
    )
    product_id: str = Field(
        ...,
        alias="productId",
        description="Id representing the product",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    asks: List[List[str]] = Field(
        ...,
        description="An array of ask tuple pairs (price, quantity) ordered in asc",
        examples=[[["4200.69", "1337.420"]]],
    )
    bids: List[List[str]] = Field(
        ...,
        description="An array of bid tuple pairs (price, quantity) ordered in desc",
        examples=[[["4199.42", "420.55"]]],
    )


class MarketPriceDto(BaseModel):
    product_id: str = Field(
        ...,
        alias="productId",
        description="Id representing the registered product",
        examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"],
    )
    best_bid_price: Optional[str] = Field(
        None,
        alias="bestBidPrice",
        description="Best bid price in USD expressed as a decimal (precision: 9)",
        examples=["104399.65"],
    )
    best_ask_price: Optional[str] = Field(
        None,
        alias="bestAskPrice",
        description="Best ask price in USD expressed as a decimal (precision: 9)",
        examples=["104400.1"],
    )
    oracle_price: Optional[str] = Field(
        None,
        alias="oraclePrice",
        description="Oracle price in USD expressed as a decimal (precision: 9)",
        examples=["104399.7"],
    )
    price24h_ago: Optional[str] = Field(
        None,
        alias="price24hAgo",
        description="Price of product 24hrs ago in USD expressed as a decimal (precision: 9)",
        examples=["101228.38"],
    )


class ListOfMarketPriceDtos(BaseModel):
    data: List[MarketPriceDto] = Field(..., description="Array of market price objects")


class FundingDto(BaseModel):
    created_at: float = Field(
        ...,
        alias="createdAt",
        description="Funding charge timestamp (ms since Unix Epoch)",
        examples=[1712019600000],
    )
    funding_rate1h: str = Field(
        ...,
        alias="fundingRate1h",
        description="Hourly funding rate",
        examples=["0.013876480"],
    )


class PageOfFundingDtos(BaseModel):
    has_next: bool = Field(
        ...,
        alias="hasNext",
        description="Whether there are more objects to paginate through",
        examples=[True],
    )
    next_cursor: Optional[str] = Field(
        None,
        alias="nextCursor",
        description="Pointer to the next page in pagination dataset",
    )
    data: List[FundingDto] = Field(
        ..., description="Array of funding rate history objects"
    )


class ProjectedFundingDto(BaseModel):
    funding_rate_projected1h: str = Field(
        ...,
        alias="fundingRateProjected1h",
        description="Projected funding rate",
        examples=["0.013876480"],
    )
    funding_rate1h: str = Field(
        ..., alias="fundingRate1h", description="Funding rate", examples=["0.013876480"]
    )


class Order(Enum):
    asc = "asc"
    desc = "desc"


class OrderBy(Enum):
    created_at = "createdAt"
    name = "name"


class V1SubaccountGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    name: Optional[constr(max_length=66)] = None
    sender: str
    order_by: Optional[OrderBy] = Field(None, alias="orderBy", examples=["createdAt"])


class V1SubaccountBalanceGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: str = Field(..., alias="subaccountId")


class V1LinkedSignerQuotaGetParametersQuery(BaseModel):
    subaccount_id: str = Field(..., alias="subaccountId")


class OrderBy1(Enum):
    created_at = "createdAt"
    expires_at = "expiresAt"
    is_active = "isActive"


class V1LinkedSignerGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: str = Field(..., alias="subaccountId")
    active: Optional[bool] = Field(None, examples=[True])
    order_by: Optional[OrderBy1] = Field(None, alias="orderBy", examples=["createdAt"])


class OrderBy2(Enum):
    created_at = "createdAt"


class V1TokenWithdrawGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: str = Field(..., alias="subaccountId")
    active: Optional[bool] = Field(None, examples=[True])
    order_by: Optional[OrderBy2] = Field(None, alias="orderBy", examples=["createdAt"])


class Status3(Enum):
    submitted = "SUBMITTED"
    pending = "PENDING"
    completed = "COMPLETED"
    rejected = "REJECTED"


class V1TokenTransferGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: str = Field(..., alias="subaccountId")
    statuses: Optional[List[Status3]] = Field(None, examples=["COMPLETED"])
    order_by: Optional[OrderBy2] = Field(None, alias="orderBy", examples=["createdAt"])


class V1TokenGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    deposit_enabled: Optional[bool] = Field(
        None, alias="depositEnabled", examples=[True]
    )
    withdraw_enabled: Optional[bool] = Field(
        None, alias="withdrawEnabled", examples=[True]
    )
    order_by: Optional[OrderBy2] = Field(None, alias="orderBy", examples=["createdAt"])


class Side6(Enum):
    number_0 = 0
    number_1 = 1


class StopType3(Enum):
    number_0 = 0
    number_1 = 1


class Status4(Enum):
    canceled = "CANCELED"
    expired = "EXPIRED"
    filled = "FILLED"
    filled_partial = "FILLED_PARTIAL"
    new = "NEW"
    pending = "PENDING"
    rejected = "REJECTED"
    submitted = "SUBMITTED"


class OrderBy5(Enum):
    type = "type"
    quantity = "quantity"
    price = "price"
    created_at = "createdAt"


class V1OrderGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: str = Field(..., alias="subaccountId")
    product_ids: Optional[List[str]] = Field(None, alias="productIds")
    created_after: Optional[float] = Field(None, alias="createdAfter")
    created_before: Optional[float] = Field(None, alias="createdBefore")
    side: Optional[Side6] = None
    close: Optional[bool] = None
    stop_types: Optional[List[StopType3]] = Field(None, alias="stopTypes", examples=[0])
    statuses: Optional[List[Status4]] = Field(None, examples=["FILLED"])
    order_by: Optional[OrderBy5] = Field(None, alias="orderBy", examples=["type"])


class OrderBy6(Enum):
    product_id = "productId"
    filled = "filled"
    price = "price"
    created_at = "createdAt"


class V1OrderFillGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: str = Field(..., alias="subaccountId")
    product_ids: Optional[List[str]] = Field(None, alias="productIds")
    created_after: Optional[float] = Field(None, alias="createdAfter")
    created_before: Optional[float] = Field(None, alias="createdBefore")
    side: Optional[Side6] = None
    statuses: Optional[List[Status4]] = None
    order_by: Optional[OrderBy6] = Field(None, alias="orderBy", examples=["productId"])
    include_self_trades: Optional[bool] = Field(False, alias="includeSelfTrades")


class OrderBy7(Enum):
    created_at = "createdAt"
    price = "price"
    filled = "filled"


class V1OrderTradeGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    product_id: Optional[str] = Field(
        None, alias="productId", examples=["1b67d5b3-9dc7-4410-bc9c-7fd23ebd32ee"]
    )
    order_by: Optional[OrderBy7] = Field(None, alias="orderBy", examples=["createdAt"])


class OrderBy8(Enum):
    size = "size"
    created_at = "createdAt"
    updated_at = "updatedAt"


class V1PositionGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    subaccount_id: str = Field(..., alias="subaccountId")
    product_id: Optional[str] = Field(None, alias="productId")
    open: Optional[bool] = Field(None, examples=[True])
    order_by: Optional[OrderBy8] = Field(None, alias="orderBy", examples=["size"])


class OrderBy9(Enum):
    price = "price"
    filled = "filled"
    created_at = "createdAt"


class V1PositionFillGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    position_id: str = Field(
        ..., alias="positionId", examples=["81215694-2d9f-4a87-af57-a710118938c0"]
    )
    order_by: Optional[OrderBy9] = Field(None, alias="orderBy", examples=["price"])


class OrderBy10(Enum):
    created_at = "createdAt"
    open_interest = "openInterest"
    base_token_name = "baseTokenName"
    quote_token_name = "quoteTokenName"


class V1ProductGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    order_by: Optional[OrderBy10] = Field(None, alias="orderBy", examples=["createdAt"])
    ticker: Optional[constr(min_length=1, max_length=32)] = Field(
        None, examples=["ETHUSD"]
    )


class V1ProductMarketLiquidityGetParametersQuery(BaseModel):
    product_id: str = Field(
        ..., alias="productId", examples=["9036443a-441a-4a66-87f2-bd5c44cdca7a"]
    )


class V1ProductMarketPriceGetParametersQuery(BaseModel):
    product_ids: List[str] = Field(..., alias="productIds", max_length=20, min_length=1)


class Range(Enum):
    day = "DAY"
    week = "WEEK"
    month = "MONTH"


class OrderBy11(Enum):
    created_at = "createdAt"


class V1FundingGetParametersQuery(BaseModel):
    order: Optional[Order] = None
    limit: Optional[float] = None
    cursor: Optional[str] = None
    product_id: str = Field(..., alias="productId")
    range: Range = Field(..., examples=["DAY"])
    order_by: Optional[OrderBy11] = Field(None, alias="orderBy", examples=["createdAt"])


class V1FundingProjectedGetParametersQuery(BaseModel):
    product_id: str = Field(..., alias="productId")
