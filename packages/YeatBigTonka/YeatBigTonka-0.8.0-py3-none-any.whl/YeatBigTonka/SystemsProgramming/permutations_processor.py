from itertools import permutations


# Определим простой декоратор, который (по желанию)
# может выполнять дополнительную логику до/после вычисления
def median_decorator(func):
    def wrapper(self, *args, **kwargs):
        # Например, можно вывести информационное сообщение
        # (или логи писать, валидировать и т.д.)
        # print("Вычисление медианы...")
        return func(self, *args, **kwargs)

    return wrapper


class Class:
    def __init__(self, nums):
        """
        Конструктор принимает список уникальных натуральных чисел (по условию).
        Здесь для примера не запрещаем 0, чтобы пример из условия работал.
        """
        # Сохраним только уникальные элементы.
        # Если нужно строго проверить, что все числа натуральные (1 и выше), можно дополнительно проверить это.
        self.nums = list(set(nums))
        self.solution = []  # здесь будут храниться все перестановки

    def permute(self):
        """Формирует все перестановки массива self.nums и сохраняет их в self.solution."""
        self.solution = [list(p) for p in permutations(self.nums)]

    def __str__(self):
        """
        Задает строковое представление объекта:
        'Для массива [a, b, c] будут такие перестановки: [[...], [...], ...]'
        """
        return f"Для массива {self.nums} будут такие перестановки: {self.solution}"

    @median_decorator
    def mediana(self):
        """
        Метод, декорированный нашим декоратором.
        Возвращает медиану исходного массива self.nums.

        Примеры:
          - Для [1, 2, 3] медиана = 2
          - Для [0, 3] медиана = (0 + 3)/2 = 1.5
        """
        arr = sorted(self.nums)
        n = len(arr)
        if n == 0:
            return None  # или как-то иначе обрабатывать пустой случай

        # Если длина массива нечетная – возвращаем средний элемент
        if n % 2 == 1:
            return arr[n // 2]
        else:
            # Если четная, то среднее арифметическое двух средних элементов
            return (arr[n // 2 - 1] + arr[n // 2]) / 2


if __name__ == "__main__":
    # Пример 1
    a = Class([1, 2, 3])
    a.permute()
    print(a)  # Для массива [1, 2, 3] будут такие перестановки: ...
    print(a.mediana())  # 2

    # Пример 2
    b = Class([0, 3])
    b.permute()
    print(b)  # Для массива [0, 3] будут такие перестановки: [[0, 3], [3, 0]]
    print(b.mediana())  # 1.5
